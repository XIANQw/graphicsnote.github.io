<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="description" content="图形学笔记">
    
    <link rel="canonical" href="https://xianqw.github.io/graphicsnote.github.io/%E5%9F%BA%E4%BA%8EMalioc%E9%9D%99%E6%80%81%E5%88%86%E6%9E%90Shader/">
    <link rel="shortcut icon" href="../img/favicon.ico">

    
    <title>Shader静态分析 - 图形学笔记</title>
    

    <link rel="stylesheet" href="https://use.fontawesome.com/releases/v5.12.0/css/all.css">
    <link rel="stylesheet" href="https://use.fontawesome.com/releases/v5.12.0/css/v4-shims.css">
    <link rel="stylesheet" href="//cdn.jsdelivr.net/npm/hack-font@3.3.0/build/web/hack.min.css">
    <link href='//rsms.me/inter/inter.css' rel='stylesheet' type='text/css'>
    <link href='//fonts.googleapis.com/css?family=Open+Sans:300italic,400italic,700italic,400,300,600,700&subset=latin-ext,latin' rel='stylesheet' type='text/css'>
    <link href="../css/bootstrap-custom.min.css" rel="stylesheet">
    <link href="../css/base.min.css" rel="stylesheet">
    <link href="../css/cinder.min.css" rel="stylesheet">

    
        
        <link rel="stylesheet" href="//cdn.jsdelivr.net/gh/highlightjs/cdn-release@9.18.0/build/styles/github.min.css">
        
    

    <!-- HTML5 shim and Respond.js IE8 support of HTML5 elements and media queries -->
    <!--[if lt IE 9]>
            <script src="https://cdn.jsdelivr.net/npm/html5shiv@3.7.3/dist/html5shiv.min.js"></script>
            <script src="https://cdn.jsdelivr.net/npm/respond.js@1.4.2/dest/respond.min.js"></script>
        <![endif]-->

    

     
</head>

<body>

    <div class="navbar navbar-default navbar-fixed-top" role="navigation">
    <div class="container">

        <!-- Collapsed navigation -->
        <div class="navbar-header">
            <!-- Expander button -->
            <button type="button" class="navbar-toggle" data-toggle="collapse" data-target=".navbar-collapse">
                <span class="sr-only">Toggle navigation</span>
                <span class="icon-bar"></span>
                <span class="icon-bar"></span>
                <span class="icon-bar"></span>
            </button>
            

            <!-- Main title -->

            
              <a class="navbar-brand" href="..">图形学笔记</a>
            
        </div>

        <!-- Expanded navigation -->
        <div class="navbar-collapse collapse">
                <!-- Main navigation -->
                <ul class="nav navbar-nav">
                
                
                    <li >
                        <a href="..">主页</a>
                    </li>
                
                
                
                    <li class="dropdown active">
                        <a href="#" class="dropdown-toggle" data-toggle="dropdown">目录 <b class="caret"></b></a>
                        <ul class="dropdown-menu">
                        
                            
<li >
    <a href="../NormalMap/">法线纹理</a>
</li>

                        
                            
<li class="active">
    <a href="./">Shader静态分析</a>
</li>

                        
                        </ul>
                    </li>
                
                
                </ul>

            <ul class="nav navbar-nav navbar-right">
                    <li>
                        <a href="#" data-toggle="modal" data-target="#mkdocs_search_modal">
                            <i class="fas fa-search"></i> Search
                        </a>
                    </li>
                    <li >
                        <a rel="prev" href="../NormalMap/">
                            <i class="fas fa-arrow-left"></i> Previous
                        </a>
                    </li>
                    <li class="disabled">
                        <a rel="next" >
                            Next <i class="fas fa-arrow-right"></i>
                        </a>
                    </li>
                    <li>
                        <a href="https://github.com/XIANQw/graphicsnote.github.io"><i class="fab fa-github"></i> GitHub</a>
                    </li>
            </ul>
        </div>
    </div>
</div>

    <div class="container">
        
        
        <div class="col-md-3"><div class="bs-sidebar hidden-print affix well" role="complementary">
    <ul class="nav bs-sidenav">
        <li class="first-level active"><a href="#maliocshader">基于Malioc静态分析Shader</a></li>
            <li class="second-level"><a href="#mali-offline-compiler">Mali Offline Compiler</a></li>
                
            <li class="second-level"><a href="#_1">使用方法</a></li>
                
            <li class="second-level"><a href="#_2">性能分析</a></li>
                
            <li class="second-level"><a href="#mali-gpu">Mali GPU 静态分析数据项</a></li>
                
                <li class="third-level"><a href="#bifrost">Bifrost架构</a></li>
                <li class="third-level"><a href="#valhall">Valhall 架构</a></li>
            <li class="second-level"><a href="#_3">测试各项数据</a></li>
                
                <li class="third-level"><a href="#1-shader">1. 基准Shader</a></li>
                <li class="third-level"><a href="#2">2. 采样两次</a></li>
                <li class="third-level"><a href="#3">3. 添加顶点法线</a></li>
                <li class="third-level"><a href="#4">4. 添加半精度顶点法线</a></li>
                <li class="third-level"><a href="#5-uv">5. 两套uv</a></li>
                <li class="third-level"><a href="#6-v2fappdata">6. 增大v2f不改变appData</a></li>
                <li class="third-level"><a href="#7-half4">7. 合并half4</a></li>
                <li class="third-level"><a href="#8-uniform">8. 增加多个uniform变量</a></li>
            <li class="second-level"><a href="#_4">总结</a></li>
                
    </ul>
</div></div>
        <div class="col-md-9" role="main">

<h1 id="maliocshader">基于Malioc静态分析Shader</h1>
<h2 id="mali-offline-compiler">Mali Offline Compiler</h2>
<p><code>malioc</code> 是<code>arm</code>推出的基于<code>mali GPU</code>的<code>shader</code>离线静态分析工具.</p>
<p>支持以下GPU</p>
<pre><code>• Mali-T700 series (Midgard architecture)
• Mali-T800 series (Midgard architecture)
• Mali‑G31 (Bifrost architecture)
• Mali‑G51 and Mali‑G52 (Bifrost architecture)
• Mali‑G71, Mali-G72, and Mali-G76 (Bifrost architecture)
• Mali‑G57, Mali‑G68, Mali‑G77, and Mali‑G78 (Valhall architecture)
</code></pre>
<h2 id="_1">使用方法</h2>
<p>命令行输入</p>
<pre><code>malioc -c &lt;target_gpu&gt; [&lt;shader_type&gt;] &lt;file1&gt; [&lt;file2&gt; …] [-o &lt;file&gt;]
</code></pre>
<p><code>shader_type</code>可输入</p>
<pre><code>• --vertex
• --tessellation_control
• --tessellation_evaluation
• --geometry
• --fragment
• --compute
</code></pre>
<p>如果<code>file</code>已经使用了以下扩展名则无需指定<code>shader_type</code></p>
<pre><code>.vert OpenGL ES vertex shader.
.tesc OpenGL ES tessellation control shader.
.tese OpenGL ES tessellation evaluation shader.
.geom OpenGL ES geometry shader.
.frag OpenGL ES fragment shader.
.comp OpenGL ES compute shader.
</code></pre>
<p>用<code>-D</code>可以定义<code>Shader</code>中的宏来执行部分代码</p>
<pre><code class="language-txt">-Dfoo
定义foo为1
-Dfoo=bar
定义foo为bar的值
</code></pre>
<h2 id="_2">性能分析</h2>
<p>执行以下命令行代码</p>
<pre><code class="language-txt">$ malioc.exe Unlit-test-LOD100.vert
</code></pre>
<p>得到以下性能数据</p>
<pre><code class="language-txt">Mali Offline Compiler v7.4.0 (Build 330167)
Copyright 2007-2021 Arm Limited, all rights reserved

Configuration
=============

Hardware: Mali-G710 r0p0
Architecture: Valhall
Driver: r32p0-00rel0
Shader type: OpenGL ES Vertex

Main shader
===========

Position variant
----------------

Work registers: 19
Uniform registers: 44
Stack spilling: false
16-bit arithmetic: 0%

                              FMA     CVT     SFU      LS       T    Bound
Total instruction cycles:    0.25    0.00    0.00    2.00    0.00       LS
Shortest path cycles:        0.25    0.00    0.00    2.00    0.00       LS
Longest path cycles:         0.25    0.00    0.00    2.00    0.00       LS

FMA = Arith FMA, CVT = Arith CVT, SFU = Arith SFU, LS = Load/Store, T = Texture

Varying variant
---------------

Work registers: 7
Uniform registers: 12
Stack spilling: false
16-bit arithmetic: 0%

                              FMA     CVT     SFU      LS       T    Bound
Total instruction cycles:    0.02    0.00    0.00    3.00    0.00       LS
Shortest path cycles:        0.02    0.00    0.00    3.00    0.00       LS
Longest path cycles:         0.02    0.00    0.00    3.00    0.00       LS

FMA = Arith FMA, CVT = Arith CVT, SFU = Arith SFU, LS = Load/Store, T = Texture

Shader properties
=================

Has uniform computation: false
</code></pre>
<p>看到<code>vertex shader</code>被分为了<code>Position variant</code>和<code>Varing variant</code>两段. 在<code>Bifrost</code>和<code>Valhall</code>架构上, <code>.vert</code>会被<code>Index-Driven Vertex Shading (IDVS)</code>管线编译成两个<code>binaries</code></p>
<ul>
<li><code>Position shader</code>: 只有<code>position</code>相关计算</li>
<li><code>Varying Shader</code>: 计算剩下的所有<code>vertex attribute</code></li>
</ul>
<p><img alt="IDVS架构" src="../img/IDVS%E6%9E%B6%E6%9E%84.png" /></p>
<p><code>Pos shader</code>对每一个索引顶点都会执行, <code>Varying shader</code>只对剔除后的可见图元执行, 所以这两个<code>shader</code>的数据被分开表示.<br />
原文:</p>
<blockquote>
<p>The position shader is executed for every index vertex, but the varying shader is only executed for vertices that are part of a visible primitive that survives culling. Mali Offline Compiler reports separate performance tables for each of these variants.</p>
</blockquote>
<h2 id="mali-gpu">Mali GPU 静态分析数据项</h2>
<h3 id="bifrost">Bifrost架构</h3>
<ul>
<li><code>Arithmetic unit (A)</code><br />
  计算单元</li>
<li><code>Load/store unit (LS)</code><br />
  执行所有非Texture的内存访问, 包括buffer, image和原子操作, 受<code>vertex</code>的结构大小影响</li>
<li><code>Varying unit (V)</code><br />
  执行变量插值, 受<code>struct v2f</code>大小影响</li>
<li><code>Texture unit (T)</code><br />
  执行所有纹理采样和过滤操作</li>
</ul>
<p><img alt="Bifrost架构" src="../img/Bifrost%E6%9E%B6%E6%9E%84.png" /></p>
<h4 id="work-registers">Work registers</h4>
<p><code>Bifrost GPU shader core</code> 可以创建多个线程, 取决于正在使用的<code>Shader programs</code>的<code>work registers</code>数量</p>
<ul>
<li><code>0-32 registers</code>:
Maximum thread capacity</li>
<li><code>33-64 registers</code>:
Half thread capacity<br />
所以如果比起<code>highp</code>, 尽可能使用更多的<code>mediump</code>的话就能创建更多线程来让<code>GPU</code>的负载上升从而提高性能</li>
</ul>
<h3 id="valhall">Valhall 架构</h3>
<p><code>Valhall</code>有6种并行管线, 其中3种<code>arithmetic</code>管线和3种<code>fixted function support</code>管线</p>
<ul>
<li>
<p><code>Arithmetic fused multiply accumulate unit (FMA)</code><br />
FMA管线构建了16-wide warp, 每线程每时钟周期可以发出一个32-bit操作或者两个16bit操作  </p>
<blockquote>
<p>The FMA pipelines are the main arithmetic pipelines, implementing the floating-point multipliers that are widely used in shader code. Each FMA pipeline implements a 16-wide warp, and can issue a single 32-bit operation or two 16-bit operations per thread and per clock cycle.</p>
</blockquote>
</li>
<li>
<p><code>Arithmetic convert unit (CVT)</code><br />
类型转换单元</p>
<blockquote>
<p>The CVT pipelines implement simple operations, such as format conversion and integer
addition.</p>
</blockquote>
</li>
<li>
<p><code>Arithmetic special functions unit (SFU)</code><br />
特殊运算单元, 用于执行倒数和<a href="https://zh.wikipedia.org/wiki/%E8%B6%85%E8%B6%8A%E5%87%BD%E6%95%B8">超越函数</a>. </p>
<blockquote>
<p>Each SFU pipeline implements a 4-wide issue path, executing a 16-wide warp over 4 clock cycles</p>
</blockquote>
</li>
<li>
<p><code>Load/store unit (LS)</code> </p>
</li>
<li><code>Varying unit (V)</code></li>
<li><code>Texture unit (T)</code>  </li>
</ul>
<p><img alt="Valhall架构" src="../img/Valhall%E6%9E%B6%E6%9E%84.png" /></p>
<h2 id="_3">测试各项数据</h2>
<h3 id="1-shader">1. 基准Shader</h3>
<p>以最基础的shader, 顶点只有pos和uv, 且采样一次纹理并输出结果作为基准shader. 再添加其它代码观察各项数据的变化</p>
<details><summary><strong>代码（点击）</strong></summary>


<pre><code>Shader &quot;Unlit/benchShader&quot;
{
    Properties
    {
        _MainTex (&quot;Texture&quot;, 2D) = &quot;white&quot; {}
    }
    SubShader
    {
        Tags { &quot;RenderType&quot;=&quot;Opaque&quot; }
        LOD 100

        Pass
        {
            CGPROGRAM
            #pragma vertex vert
            #pragma fragment frag

            #include &quot;UnityCG.cginc&quot;

            struct appdata
            {
                float4 vertex : POSITION;
                float2 uv : TEXCOORD0;
            };

            struct v2f
            {
                float2 uv : TEXCOORD0;
                float4 vertex : SV_POSITION;
            };

            sampler2D _MainTex;
            float4 _MainTex_ST;

            v2f vert (appdata v)
            {
                v2f o;
                o.vertex = UnityObjectToClipPos(v.vertex);
                o.uv = TRANSFORM_TEX(v.uv, _MainTex);
                return o;
            }

            fixed4 frag (v2f i) : SV_Target
            {
                // sample the texture
                fixed4 col = tex2D(_MainTex, i.uv);
                return col;
            }
            ENDCG
        }
    }
}

=======================================================================

#version 300 es

#define HLSLCC_ENABLE_UNIFORM_BUFFERS 1
#if HLSLCC_ENABLE_UNIFORM_BUFFERS
#define UNITY_UNIFORM
#else
#define UNITY_UNIFORM uniform
#endif
#define UNITY_SUPPORTS_UNIFORM_LOCATION 1
#if UNITY_SUPPORTS_UNIFORM_LOCATION
#define UNITY_LOCATION(x) layout(location = x)
#define UNITY_BINDING(x) layout(binding = x, std140)
#else
#define UNITY_LOCATION(x)
#define UNITY_BINDING(x) layout(std140)
#endif
uniform     vec4 hlslcc_mtx4x4unity_ObjectToWorld[4];
uniform     vec4 hlslcc_mtx4x4unity_MatrixVP[4];
uniform     vec4 _MainTex_ST;
in highp vec4 in_POSITION0;
in highp vec2 in_TEXCOORD0;
out highp vec2 vs_TEXCOORD0;
vec4 u_xlat0;
vec4 u_xlat1;
void main()
{
    vs_TEXCOORD0.xy = in_TEXCOORD0.xy * _MainTex_ST.xy + _MainTex_ST.zw;
    u_xlat0 = in_POSITION0.yyyy * hlslcc_mtx4x4unity_ObjectToWorld[1];
    u_xlat0 = hlslcc_mtx4x4unity_ObjectToWorld[0] * in_POSITION0.xxxx + u_xlat0;
    u_xlat0 = hlslcc_mtx4x4unity_ObjectToWorld[2] * in_POSITION0.zzzz + u_xlat0;
    u_xlat0 = u_xlat0 + hlslcc_mtx4x4unity_ObjectToWorld[3];
    u_xlat1 = u_xlat0.yyyy * hlslcc_mtx4x4unity_MatrixVP[1];
    u_xlat1 = hlslcc_mtx4x4unity_MatrixVP[0] * u_xlat0.xxxx + u_xlat1;
    u_xlat1 = hlslcc_mtx4x4unity_MatrixVP[2] * u_xlat0.zzzz + u_xlat1;
    gl_Position = hlslcc_mtx4x4unity_MatrixVP[3] * u_xlat0.wwww + u_xlat1;
    return;
}

==============================================================================

#version 300 es

precision highp float;
precision highp int;
#define UNITY_SUPPORTS_UNIFORM_LOCATION 1
#if UNITY_SUPPORTS_UNIFORM_LOCATION
#define UNITY_LOCATION(x) layout(location = x)
#define UNITY_BINDING(x) layout(binding = x, std140)
#else
#define UNITY_LOCATION(x)
#define UNITY_BINDING(x) layout(std140)
#endif
UNITY_LOCATION(0) uniform mediump sampler2D _MainTex;
in highp vec2 vs_TEXCOORD0;
layout(location = 0) out mediump vec4 SV_Target0;
mediump vec4 u_xlat16_0;
void main()
{
    u_xlat16_0 = texture(_MainTex, vs_TEXCOORD0.xy);
    SV_Target0 = u_xlat16_0;
    return;
}


</code></pre>


</details>

<p>分析结果<br />
<img alt="BenchmarkShader" src="../img/BenchmarkShader.png" /></p>
<h3 id="2">2. 采样两次</h3>
<details><summary><strong>代码（点击）</strong></summary>


<pre><code>v2f vert (appdata v)
{
    v2f o;
    o.vertex = UnityObjectToClipPos(v.vertex);
    o.uv = TRANSFORM_TEX(v.uv, _MainTex);
    return o;
}

fixed4 frag (v2f i) : SV_Target
{
    // sample the texture
    fixed4 col = tex2D(_MainTex, i.uv);
    col.rg = tex2D(_MainTex, i.uv + float2(0, 1));
    return col;
}

===========================================================

#version 300 es

precision highp float;
precision highp int;
#define UNITY_SUPPORTS_UNIFORM_LOCATION 1
#if UNITY_SUPPORTS_UNIFORM_LOCATION
#define UNITY_LOCATION(x) layout(location = x)
#define UNITY_BINDING(x) layout(binding = x, std140)
#else
#define UNITY_LOCATION(x)
#define UNITY_BINDING(x) layout(std140)
#endif
UNITY_LOCATION(0) uniform mediump sampler2D _MainTex;
in highp vec2 vs_TEXCOORD0;
layout(location = 0) out mediump vec4 SV_Target0;
vec4 u_xlat0;
void main()
{
    u_xlat0.xy = vs_TEXCOORD0.xy + vec2(0.0, 1.0);
    u_xlat0.xy = texture(_MainTex, u_xlat0.xy).xy;
    u_xlat0.zw = texture(_MainTex, vs_TEXCOORD0.xy).zw;
    SV_Target0 = u_xlat0;
    return;
}

</code></pre>

</details>

<p>分析结果<br />
<img alt="采样两次" src="../img/%E9%87%87%E6%A0%B7%E4%B8%A4%E6%AC%A1.png" /></p>
<h3 id="3">3. 添加顶点法线</h3>
<details><summary><strong>代码（点击）</strong></summary>
<!-- </details> -->


<pre><code>struct appdata
{
    float4 vertex : POSITION;
    float3 normal: NORMAL; // 顶点法线
    float2 uv1 : TEXCOORD0;
};

struct v2f
{
    float4 vertex : SV_POSITION;
    float3 normalWorld: TEXCOORD1;
    float2 uv1 : TEXCOORD0;
};

sampler2D _MainTex;
float4 _MainTex_ST;

v2f vert (appdata v)
{
    v2f o;
    o.vertex = UnityObjectToClipPos(v.vertex);
    o.uv1 = TRANSFORM_TEX(v.uv1, _MainTex);
    o.normalWorld = UnityObjectToWorldNormal(v.normal);
    return o;
}

fixed4 frag (v2f i) : SV_Target
{
    // sample the texture
    half2 uv = i.uv1;
    fixed4 col = tex2D(_MainTex, uv);
    col.rg = i.normalWorld.xy;
    return col;
}
===============================================================

#version 300 es

#define HLSLCC_ENABLE_UNIFORM_BUFFERS 1
#if HLSLCC_ENABLE_UNIFORM_BUFFERS
#define UNITY_UNIFORM
#else
#define UNITY_UNIFORM uniform
#endif
#define UNITY_SUPPORTS_UNIFORM_LOCATION 1
#if UNITY_SUPPORTS_UNIFORM_LOCATION
#define UNITY_LOCATION(x) layout(location = x)
#define UNITY_BINDING(x) layout(binding = x, std140)
#else
#define UNITY_LOCATION(x)
#define UNITY_BINDING(x) layout(std140)
#endif
uniform     vec4 hlslcc_mtx4x4unity_ObjectToWorld[4];
uniform     vec4 hlslcc_mtx4x4unity_WorldToObject[4];
uniform     vec4 hlslcc_mtx4x4unity_MatrixVP[4];
uniform     vec4 _MainTex_ST;
in highp vec4 in_POSITION0;
in highp vec3 in_NORMAL0;
in highp vec2 in_TEXCOORD0;
out highp vec3 vs_TEXCOORD1;
out highp vec2 vs_TEXCOORD0;
vec4 u_xlat0;
vec4 u_xlat1;
float u_xlat6;
void main()
{
    u_xlat0 = in_POSITION0.yyyy * hlslcc_mtx4x4unity_ObjectToWorld[1];
    u_xlat0 = hlslcc_mtx4x4unity_ObjectToWorld[0] * in_POSITION0.xxxx + u_xlat0;
    u_xlat0 = hlslcc_mtx4x4unity_ObjectToWorld[2] * in_POSITION0.zzzz + u_xlat0;
    u_xlat0 = u_xlat0 + hlslcc_mtx4x4unity_ObjectToWorld[3];
    u_xlat1 = u_xlat0.yyyy * hlslcc_mtx4x4unity_MatrixVP[1];
    u_xlat1 = hlslcc_mtx4x4unity_MatrixVP[0] * u_xlat0.xxxx + u_xlat1;
    u_xlat1 = hlslcc_mtx4x4unity_MatrixVP[2] * u_xlat0.zzzz + u_xlat1;
    gl_Position = hlslcc_mtx4x4unity_MatrixVP[3] * u_xlat0.wwww + u_xlat1;
    u_xlat0.x = dot(in_NORMAL0.xyz, hlslcc_mtx4x4unity_WorldToObject[0].xyz);
    u_xlat0.y = dot(in_NORMAL0.xyz, hlslcc_mtx4x4unity_WorldToObject[1].xyz);
    u_xlat0.z = dot(in_NORMAL0.xyz, hlslcc_mtx4x4unity_WorldToObject[2].xyz);
    u_xlat6 = dot(u_xlat0.xyz, u_xlat0.xyz);
    u_xlat6 = inversesqrt(u_xlat6);
    vs_TEXCOORD1.xyz = vec3(u_xlat6) * u_xlat0.xyz;
    vs_TEXCOORD0.xy = in_TEXCOORD0.xy * _MainTex_ST.xy + _MainTex_ST.zw;
    return;
}



===========================================================================
#version 300 es

precision highp float;
precision highp int;
#define UNITY_SUPPORTS_UNIFORM_LOCATION 1
#if UNITY_SUPPORTS_UNIFORM_LOCATION
#define UNITY_LOCATION(x) layout(location = x)
#define UNITY_BINDING(x) layout(binding = x, std140)
#else
#define UNITY_LOCATION(x)
#define UNITY_BINDING(x) layout(std140)
#endif
UNITY_LOCATION(0) uniform mediump sampler2D _MainTex;
in highp vec3 vs_TEXCOORD1;
in highp vec2 vs_TEXCOORD0;
layout(location = 0) out mediump vec4 SV_Target0;
vec4 u_xlat0;
void main()
{
    u_xlat0.zw = texture(_MainTex, vs_TEXCOORD0.xy).zw;
    u_xlat0.xy = vs_TEXCOORD1.xy;
    SV_Target0 = u_xlat0;
    return;
}




</code></pre>

</details>

<p>分析结果<br />
<img alt="顶点法线" src="../img/%E6%B7%BB%E5%8A%A0%E9%A1%B6%E7%82%B9%E6%B3%95%E7%BA%BF1.png" /></p>
<ol>
<li><code>o.normalWorld = UnityObjectToWorldNormal(v.normal);</code>转换法线到世界空间后做了<code>normalize</code>, 使用了<code>inversesqrt</code>, 增加了<code>SFU</code></li>
<li>新增了<code>in highp vec3 in_NORMAL0;</code>和<code>out highp vec3 vs_TEXCOORD1</code>使得<code>LS</code>和<code>V</code>上升.</li>
</ol>
<h3 id="4">4. 添加半精度顶点法线</h3>
<details><summary><strong>代码（点击）</strong></summary>


<pre><code>struct appdata
{
    float4 vertex : POSITION;
    half3 normal: NORMAL;
    float2 uv : TEXCOORD0;
};

struct v2f
{
    float4 vertex : SV_POSITION;
    half3 normalWorld: TEXCOORD1;
    float2 uv : TEXCOORD0;
};
====================================
in mediump vec3 in_NORMAL0;
out mediump vec3 vs_TEXCOORD1;

</code></pre>


</details>

<p>分析结果<br />
<img alt="半精度法线" src="../img/%E6%B7%BB%E5%8A%A0%E5%8D%8A%E7%B2%BE%E5%BA%A6%E9%A1%B6%E7%82%B9%E6%B3%95%E7%BA%BF.png" /><br />
改为半精度后<code>V</code>开销下降, <code>SFU</code>不变</p>
<h3 id="5-uv">5. 两套uv</h3>
<p>添加第二套uv, 但不传给<code>Fragment shader</code></p>
<details><summary><strong>代码（点击）</strong></summary>


<pre><code>struct appdata
{
    float4 vertex : POSITION;
    half3 normal: NORMAL;
    half2 uv1 : TEXCOORD0;
    half2 uv2 : TEXCOORD1;
};

struct v2f
{
    float4 vertex : SV_POSITION;
    half3 normalWorld: TEXCOORD1;
    half2 uv1 : TEXCOORD0;
};
====================================
in mediump vec3 in_NORMAL0;
in mediump vec2 in_TEXCOORD0;
in mediump vec2 in_TEXCOORD1;
out mediump vec3 vs_TEXCOORD1;
out mediump vec2 vs_TEXCOORD0;

</code></pre>


</details>

<p>分析结果<br />
<img alt="2uv" src="../img/2UV.png" /></p>
<p>appData结构体属性越多, <code>VAO</code>越大造成<code>LS</code>上升</p>
<h3 id="6-v2fappdata">6. 增大v2f不改变appData</h3>
<details><summary><strong>代码（点击）</strong></summary>


<pre><code>struct appdata
{
    float4 vertex : POSITION;
    half3 normal: NORMAL;
    half2 uv1 : TEXCOORD0;
    half2 uv2 : TEXCOORD1;
};

struct v2f
{
    float4 vertex : SV_POSITION;
    half3 normalWorld: TEXCOORD1;
    half2 uv1 : TEXCOORD0;
    half2 uv2 : TEXCOORD2;
    half4 uv34 : TEXCOORD3;
};

sampler2D _MainTex;
float4 _MainTex_ST;

v2f vert (appdata v)
{
    v2f o;
    o.vertex = UnityObjectToClipPos(v.vertex);
    o.uv1 = TRANSFORM_TEX(v.uv1, _MainTex);
    o.uv2 = TRANSFORM_TEX(v.uv2, _MainTex);;
    o.uv34.xy = saturate(o.uv1 + 0.1);
    o.uv34.zw = saturate(o.uv2 - 0.1);
    o.normalWorld = UnityObjectToWorldNormal(v.normal);
    return o;
}

fixed4 frag (v2f i) : SV_Target
{
    // sample the texture
    half2 uv = (i.uv1 + i.uv2 + i.uv34.xy + i.uv34.zw) * 0.25;
    fixed4 col = tex2D(_MainTex, uv);
    col.r = i.normalWorld.x;
    return col;
}
======================================
in mediump vec3 in_NORMAL0;
in mediump vec2 in_TEXCOORD0;
in mediump vec2 in_TEXCOORD1;
out mediump vec3 vs_TEXCOORD1;
out mediump vec2 vs_TEXCOORD0;
out mediump vec2 vs_TEXCOORD2;
out mediump vec4 vs_TEXCOORD3;


</code></pre>

</details>

<p>分析结果<br />
<img alt="增大v2f" src="../img/%E5%A2%9E%E5%A4%A7v2f.png" /><br />
在<code>case4</code>的基础上, 将<code>v2f</code>增加一个<code>half2</code>和<code>half4</code>只使varying的cycles数量上升, LS不变.</p>
<h3 id="7-half4">7. 合并half4</h3>
<p>将多个half2合并成half4</p>
<details><summary><strong>代码（点击）</strong></summary>


<pre><code>struct appdata
{
    float4 vertex : POSITION;
    half3 normal: NORMAL;
    half4 uv12 : TEXCOORD0;
};

struct v2f
{
    float4 vertex : SV_POSITION;
    half3 normalWorld: TEXCOORD1;
    half4 uv12 : TEXCOORD0;
    half4 uv34 : TEXCOORD2;
};

sampler2D _MainTex;
float4 _MainTex_ST;

v2f vert (appdata v)
{
    v2f o;
    o.vertex = UnityObjectToClipPos(v.vertex);
    o.uv12.xy = TRANSFORM_TEX(v.uv12.xy, _MainTex);
    o.uv12.zw = TRANSFORM_TEX(v.uv12.zw, _MainTex);;
    o.uv34.xy = saturate(o.uv12.xy + 0.1);
    o.uv34.zw = saturate(o.uv12.zw - 0.1);
    o.normalWorld = UnityObjectToWorldNormal(v.normal);
    return o;
}

fixed4 frag (v2f i) : SV_Target
{
    // sample the texture
    half2 uv = (i.uv12.xy + i.uv12.zw + i.uv34.xy + i.uv34.zw) * 0.25;
    fixed4 col = tex2D(_MainTex, uv);
    col.r = i.normalWorld.x;
    return col;
}
============================================
in mediump vec3 in_NORMAL0;
in mediump vec4 in_TEXCOORD0;
out mediump vec3 vs_TEXCOORD1;
out mediump vec4 vs_TEXCOORD0;
out mediump vec4 vs_TEXCOORD2;

</code></pre>

</details>

<p>分析结果<br />
<img alt="合并uv" src="../img/%E5%90%88%E5%B9%B6uv.png" /><br />
<code>appdata</code>合并后<code>LS</code>下降, <code>varying</code>不变</p>
<h3 id="8-uniform">8. 增加多个uniform变量</h3>
<details><summary><strong>代码（点击）</strong></summary>


<pre><code>float param1;
float param2;
float param3;
float param4;
float param5;
float param6;

struct appdata
{
    float4 vertex : POSITION;
    half3 normal: NORMAL;
    half4 uv12 : TEXCOORD0;
};

struct v2f
{
    float4 vertex : SV_POSITION;
    half3 normalWorld: TEXCOORD1;
    half4 uv12 : TEXCOORD0;
    half4 uv34 : TEXCOORD2;
};

sampler2D _MainTex;
float4 _MainTex_ST;

v2f vert (appdata v)
{
    v2f o;
    float param = (param1+param2+param3+param4+param5+param6) / 6.0;
    o.vertex = UnityObjectToClipPos(v.vertex);
    o.uv12.xy = TRANSFORM_TEX(v.uv12.xy, _MainTex);
    o.uv12.zw = TRANSFORM_TEX(v.uv12.zw, _MainTex);;
    o.uv34.xy = saturate(o.uv12.xy + param);
    o.uv34.zw = saturate(o.uv12.zw - 0.1);
    o.normalWorld = UnityObjectToWorldNormal(v.normal);
    return o;
}

fixed4 frag (v2f i) : SV_Target
{
    // sample the texture
    half2 uv = (i.uv12.xy + i.uv12.zw + i.uv34.xy + i.uv34.zw) * 0.25;
    fixed4 col = tex2D(_MainTex, uv);
    col.r = i.normalWorld.x;
    return col;
}
=========================================================================
#version 300 es

#define HLSLCC_ENABLE_UNIFORM_BUFFERS 1
#if HLSLCC_ENABLE_UNIFORM_BUFFERS
#define UNITY_UNIFORM
#else
#define UNITY_UNIFORM uniform
#endif
#define UNITY_SUPPORTS_UNIFORM_LOCATION 1
#if UNITY_SUPPORTS_UNIFORM_LOCATION
#define UNITY_LOCATION(x) layout(location = x)
#define UNITY_BINDING(x) layout(binding = x, std140)
#else
#define UNITY_LOCATION(x)
#define UNITY_BINDING(x) layout(std140)
#endif
uniform     vec4 hlslcc_mtx4x4unity_ObjectToWorld[4];
uniform     vec4 hlslcc_mtx4x4unity_WorldToObject[4];
uniform     vec4 hlslcc_mtx4x4unity_MatrixVP[4];
uniform     float param1;
uniform     float param2;
uniform     float param3;
uniform     float param4;
uniform     float param5;
uniform     float param6;
uniform     vec4 _MainTex_ST;
in highp vec4 in_POSITION0;
in mediump vec3 in_NORMAL0;
in mediump vec4 in_TEXCOORD0;
out mediump vec3 vs_TEXCOORD1;
out mediump vec4 vs_TEXCOORD0;
out mediump vec4 vs_TEXCOORD2;
vec4 u_xlat0;
vec4 u_xlat1;
float u_xlat6;
void main()
{
    u_xlat0 = in_POSITION0.yyyy * hlslcc_mtx4x4unity_ObjectToWorld[1];
    u_xlat0 = hlslcc_mtx4x4unity_ObjectToWorld[0] * in_POSITION0.xxxx + u_xlat0;
    u_xlat0 = hlslcc_mtx4x4unity_ObjectToWorld[2] * in_POSITION0.zzzz + u_xlat0;
    u_xlat0 = u_xlat0 + hlslcc_mtx4x4unity_ObjectToWorld[3];
    u_xlat1 = u_xlat0.yyyy * hlslcc_mtx4x4unity_MatrixVP[1];
    u_xlat1 = hlslcc_mtx4x4unity_MatrixVP[0] * u_xlat0.xxxx + u_xlat1;
    u_xlat1 = hlslcc_mtx4x4unity_MatrixVP[2] * u_xlat0.zzzz + u_xlat1;
    gl_Position = hlslcc_mtx4x4unity_MatrixVP[3] * u_xlat0.wwww + u_xlat1;
    u_xlat0.x = dot(in_NORMAL0.xyz, hlslcc_mtx4x4unity_WorldToObject[0].xyz);
    u_xlat0.y = dot(in_NORMAL0.xyz, hlslcc_mtx4x4unity_WorldToObject[1].xyz);
    u_xlat0.z = dot(in_NORMAL0.xyz, hlslcc_mtx4x4unity_WorldToObject[2].xyz);
    u_xlat6 = dot(u_xlat0.xyz, u_xlat0.xyz);
    u_xlat6 = inversesqrt(u_xlat6);
    u_xlat0.xyz = vec3(u_xlat6) * u_xlat0.xyz;
    vs_TEXCOORD1.xyz = u_xlat0.xyz;
    u_xlat0 = in_TEXCOORD0 * _MainTex_ST.xyxy + _MainTex_ST.zwzw;
    vs_TEXCOORD0 = u_xlat0;
    u_xlat1.x = param2 + param1;
    u_xlat1.x = u_xlat1.x + param3;
    u_xlat1.x = u_xlat1.x + param4;
    u_xlat1.x = u_xlat1.x + param5;
    u_xlat1.x = u_xlat1.x + param6;
    u_xlat0.xy = u_xlat1.xx * vec2(0.166666672, 0.166666672) + u_xlat0.xy;
#ifdef UNITY_ADRENO_ES3
    u_xlat0.xy = min(max(u_xlat0.xy, 0.0), 1.0);
#else
    u_xlat0.xy = clamp(u_xlat0.xy, 0.0, 1.0);
#endif
    vs_TEXCOORD2.zw = u_xlat0.zw + vec2(-0.100000001, -0.100000001);
#ifdef UNITY_ADRENO_ES3
    vs_TEXCOORD2.zw = min(max(vs_TEXCOORD2.zw, 0.0), 1.0);
#else
    vs_TEXCOORD2.zw = clamp(vs_TEXCOORD2.zw, 0.0, 1.0);
#endif
    vs_TEXCOORD2.xy = u_xlat0.xy;
    return;
}

</code></pre>

</details>

<p>分析结果<br />
<img alt="添加uniform变量" src="../img/%E5%A2%9E%E5%8A%A0Uniform.png" /><br />
添加<code>Uniform</code>不影响<code>LS</code></p>
<h2 id="_4">总结</h2>
<ul>
<li><code>FMA</code>: 与加减乘除计算操作数成正比</li>
<li><code>CVT</code>: 与不同类型间计算数量成正比</li>
<li><code>SFU</code>: 与<code>inversesqrt</code>, <code>sqrt</code>, <code>normalize</code>等计算函数使用数量成正比</li>
<li><code>LS</code>: 与顶点输入结构体的<code>texcoord</code>使用数量成正比, 即使是同样数量的texcoord, 但用<code>float4</code>和<code>float2</code>, <code>LS</code>的上升是相同的.</li>
<li><code>Varying</code>: 与<code>v2f</code>结构体大小, shader间插值计算成正比</li>
<li><code>T</code>: 与贴图采样次数成正比</li>
</ul></div>
        
        
    </div>

    
      <footer class="col-md-12 text-center">
          
          
            <hr>
            <p>
            <small>Documentation built with <a href="http://www.mkdocs.org/">MkDocs</a>.</small>
            </p>
          

          
          
      </footer>
    
    <script src="//ajax.googleapis.com/ajax/libs/jquery/1.12.4/jquery.min.js"></script>
    <script src="../js/bootstrap-3.0.3.min.js"></script>

    
    <script src="//cdn.jsdelivr.net/gh/highlightjs/cdn-release@9.18.0/build/highlight.min.js"></script>
        
    <script>hljs.initHighlightingOnLoad();</script>
    

    <script>var base_url = ".."</script>
    
    <script src="../js/base.js"></script>
    <script src="../search/main.js"></script>

    <div class="modal" id="mkdocs_search_modal" tabindex="-1" role="dialog" aria-labelledby="searchModalLabel" aria-hidden="true">
    <div class="modal-dialog modal-lg">
        <div class="modal-content">
            <div class="modal-header">
                <button type="button" class="close" data-dismiss="modal">
                    <span aria-hidden="true">&times;</span>
                    <span class="sr-only">Close</span>
                </button>
                <h4 class="modal-title" id="searchModalLabel">Search</h4>
            </div>
            <div class="modal-body">
                <p>
                    From here you can search these documents. Enter
                    your search terms below.
                </p>
                <form>
                    <div class="form-group">
                        <input type="text" class="form-control" placeholder="Search..." id="mkdocs-search-query" title="Type search term here">
                    </div>
                </form>
                <div id="mkdocs-search-results"></div>
            </div>
            <div class="modal-footer">
            </div>
        </div>
    </div>
</div><div class="modal" id="mkdocs_keyboard_modal" tabindex="-1" role="dialog" aria-labelledby="keyboardModalLabel" aria-hidden="true">
    <div class="modal-dialog">
        <div class="modal-content">
            <div class="modal-header">
                <h4 class="modal-title" id="keyboardModalLabel">Keyboard Shortcuts</h4>
                <button type="button" class="close" data-dismiss="modal"><span aria-hidden="true">&times;</span><span class="sr-only">Close</span></button>
            </div>
            <div class="modal-body">
              <table class="table">
                <thead>
                  <tr>
                    <th style="width: 20%;">Keys</th>
                    <th>Action</th>
                  </tr>
                </thead>
                <tbody>
                  <tr>
                    <td class="help shortcut"><kbd>?</kbd></td>
                    <td>Open this help</td>
                  </tr>
                  <tr>
                    <td class="next shortcut"><kbd>n</kbd></td>
                    <td>Next page</td>
                  </tr>
                  <tr>
                    <td class="prev shortcut"><kbd>p</kbd></td>
                    <td>Previous page</td>
                  </tr>
                  <tr>
                    <td class="search shortcut"><kbd>s</kbd></td>
                    <td>Search</td>
                  </tr>
                </tbody>
              </table>
            </div>
            <div class="modal-footer">
            </div>
        </div>
    </div>
</div>
    </body>

</html>
