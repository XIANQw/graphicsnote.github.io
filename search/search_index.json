{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"\u56fe\u5f62\u5b66\u7b14\u8bb0 \u5c06\u4e4b\u524d\u7684\u56fe\u5f62\u5b66\u7b14\u8bb0\u5148\u642c\u79fb\u5230github pages\u4e0a\u597d\u4e86, \u628a\u8bb0\u5f55\u7684\u4e60\u60ef\u575a\u6301\u4e0b\u53bb, \u5b9a\u671f\u68b3\u7406~","title":"\u4e3b\u9875"},{"location":"#_1","text":"\u5c06\u4e4b\u524d\u7684\u56fe\u5f62\u5b66\u7b14\u8bb0\u5148\u642c\u79fb\u5230github pages\u4e0a\u597d\u4e86, \u628a\u8bb0\u5f55\u7684\u4e60\u60ef\u575a\u6301\u4e0b\u53bb, \u5b9a\u671f\u68b3\u7406~","title":"\u56fe\u5f62\u5b66\u7b14\u8bb0"},{"location":"NormalMap/","text":"\u6cd5\u7ebf\u8d34\u56fe \u6cd5\u7ebf\u8d34\u56fe\u8868\u793a\u7684\u662f\u5207\u7ebf\u7a7a\u95f4\u4e0b\u7684\u6cd5\u5411\u91cf, \u4efb\u4f55\u671d\u5411\u7684\u5e73\u9762\u90fd\u53ef\u4ee5\u9002\u7528\u540c\u4e00\u5957\u6cd5\u7ebf\u8d34\u56fe. \u4f7f\u7528 \u9876\u70b9\u6570\u636e \u9876\u70b9\u6570\u636e\u9664\u4e86 pos , texcoord , normal \u5916\u8fd8\u9700 Tangent \u6216 Bitangent . VS vs\u4e2d\u5efa\u7acbTBN\u77e9\u9635, \u7528\u4e8e\u5c06\u5207\u7ebf\u7a7a\u95f4\u7684\u6cd5\u7ebf\u8f6c\u5230\u4e16\u754c\u7a7a\u95f4\u4fbf\u4e8e\u540e\u7eed\u5149\u7167\u8ba1\u7b97 // \u5c06\u5207\u7ebf\u4ece\u6a21\u578b\u7a7a\u95f4\u8f6c\u5230\u4e16\u754c\u7a7a\u95f4 half4 tangentWorld = half4(UnityObjectToWorldDir(v.tangent.xyz), v.tangent.w); half3x3 tangentToWorld = CreateTangentToWorldPerVertex(normalWorld, tangentWorld.xyz, tangentWorld.w); // Unity\u6784\u5efaTBN\u77e9\u9635\u7684\u51fd\u6570 half3x3 CreateTangentToWorldPerVertex(half3 normal, half3 tangent, half tangentSign) { // For odd-negative scale transforms we need to flip the sign half sign = tangentSign * unity_WorldTransformParams.w; half3 binormal = cross(normal, tangent) * sign; return half3x3(tangent, binormal, normal); } Fragment half3 normalTangent = UnpackScaleNormal(tex2D (_BumpMap, texcoords.xy), _BumpScale); UnpackNormal \u91c7\u6837\u51fa\u6765\u7684\u5207\u7ebf\u7a7a\u95f4\u6cd5\u5411\u91cf, \u5c06 [0, 1] \u7a7a\u95f4\u8f6c\u6362\u56de [-1, 1] , DXT5nm \u538b\u7f29\u7684\u6cd5\u7ebf\u8d34\u56fe\u53ea\u4f1a\u5b58\u50a8 xy \u503c\u6240\u4ee5\u9700\u8981\u7b97\u51fa z // Unpack normal as DXT5nm (1, y, 1, x) or BC5 (x, y, 0, 1) // Note neutral texture like \"bump\" is (0, 0, 1, 1) to work with both plain RGB normal and DXT5nm/BC5 fixed3 UnpackNormalmapRGorAG(fixed4 packednormal) { // This do the trick packednormal.x *= packednormal.w; fixed3 normal; normal.xy = packednormal.xy * 2 - 1; normal.z = sqrt(1 - saturate(dot(normal.xy, normal.xy))); return normal; } inline fixed3 UnpackNormal(fixed4 packednormal) { #if defined(UNITY_NO_DXT5nm) return packednormal.xyz * 2 - 1; #else return UnpackNormalmapRGorAG(packednormal); #endif } \u6700\u540e\u5c06 normalTangent \u8f6c\u6362\u5230\u4e16\u754c\u7a7a\u95f4\u5750\u6807\u518d\u5f52\u4e00\u5316\u5c31\u53ef\u4ee5\u4f7f\u7528\u4e86 half3 normalWorld = normalize(mul(normalTangent, tangentToWorld)); \u8865\u5145 odd-negative scaling : \u5947\u6570\u8f74\u8d1f\u7f29\u653e, xyz\u4e2d\u67091\u62163\u4e2a\u8f74\u7684\u7f29\u653e\u503c\u4e3a\u8d1f. \u5177\u6709 odd-negative scaling \u548c\u6ca1\u6709\u7684\u7269\u4f53\u6e32\u67d3\u72b6\u6001\u4e0d\u540c, \u56e0\u6b64\u4e5f\u4e0d\u80fd\u52a8\u6001\u5408\u6279\\ \u5728Unity\u4e2d vertex.tangent.w = 1 \u6216 -1 \u4e4b\u6240\u4ee5\u52a0\u4e86\u8fd9\u4e2a\u503c, \u662f\u56e0\u4e3a\u5728 OpenGL \u548c DirectX \u5e73\u53f0\u4e0aUV\u8d70\u5411\u4e0d\u4e00\u6837. OpenGL \u5e73\u53f0\uff0cU\u6c34\u5e73\u5411\u53f3\uff0cV\u5782\u76f4\u5411\u4e0a\u5373+y\\ DirectX \u5e73\u53f0\uff0cU\u6c34\u5e73\u5411\u53f3\uff0cV\u5782\u76f4\u5411\u4e0b\u5373-y\\ \u800cUnity\u9075\u5faa\u7684\u662f OpenGL \u89c4\u8303\uff0c\u5728\u5bfc\u5165\u6a21\u578b\u7684\u65f6\u5019uv\u8d70\u5411\u662f+y\uff0c\u6240\u4ee5\u5982\u679c\u5728windows\u4e0aUnity\u7528 DirectX \u7684\u60c5\u51b5\u4e0b\uff0c\u53c9\u4e58\u5f97\u5230\u7684 B' \u521a\u597d\u53cd\u5411\u4e86\uff0c\u624b\u6027\u9519\u8bef\u3002\u6240\u4ee5Unity\u5b58\u50a8\u4e86\u4e00\u4e2a\u624b\u6027\u4fe1\u606f\u5728 tangent.w \u91cc\uff0c\u5728\u6b63\u4ea4\u5316\u6700\u540e\u5f97\u5230\u5207\u7ebf T' \u7684\u65f6\u5019\u8ba1\u7b97\u5f53\u524d\u5e73\u53f0\u7684\u624b\u6027\u503c\u5e76\u5b58\u5728 tangent.w \u4e2d\u3002 \u6240\u4ee5\u526f\u5207\u7ebf\u7684\u8ba1\u7b97\u65f6\u624d\u4f1a *sign","title":"\u6cd5\u7ebf\u7eb9\u7406"},{"location":"NormalMap/#_1","text":"\u6cd5\u7ebf\u8d34\u56fe\u8868\u793a\u7684\u662f\u5207\u7ebf\u7a7a\u95f4\u4e0b\u7684\u6cd5\u5411\u91cf, \u4efb\u4f55\u671d\u5411\u7684\u5e73\u9762\u90fd\u53ef\u4ee5\u9002\u7528\u540c\u4e00\u5957\u6cd5\u7ebf\u8d34\u56fe.","title":"\u6cd5\u7ebf\u8d34\u56fe"},{"location":"NormalMap/#_2","text":"","title":"\u4f7f\u7528"},{"location":"NormalMap/#_3","text":"\u9876\u70b9\u6570\u636e\u9664\u4e86 pos , texcoord , normal \u5916\u8fd8\u9700 Tangent \u6216 Bitangent .","title":"\u9876\u70b9\u6570\u636e"},{"location":"NormalMap/#vs","text":"vs\u4e2d\u5efa\u7acbTBN\u77e9\u9635, \u7528\u4e8e\u5c06\u5207\u7ebf\u7a7a\u95f4\u7684\u6cd5\u7ebf\u8f6c\u5230\u4e16\u754c\u7a7a\u95f4\u4fbf\u4e8e\u540e\u7eed\u5149\u7167\u8ba1\u7b97 // \u5c06\u5207\u7ebf\u4ece\u6a21\u578b\u7a7a\u95f4\u8f6c\u5230\u4e16\u754c\u7a7a\u95f4 half4 tangentWorld = half4(UnityObjectToWorldDir(v.tangent.xyz), v.tangent.w); half3x3 tangentToWorld = CreateTangentToWorldPerVertex(normalWorld, tangentWorld.xyz, tangentWorld.w); // Unity\u6784\u5efaTBN\u77e9\u9635\u7684\u51fd\u6570 half3x3 CreateTangentToWorldPerVertex(half3 normal, half3 tangent, half tangentSign) { // For odd-negative scale transforms we need to flip the sign half sign = tangentSign * unity_WorldTransformParams.w; half3 binormal = cross(normal, tangent) * sign; return half3x3(tangent, binormal, normal); }","title":"VS"},{"location":"NormalMap/#fragment","text":"half3 normalTangent = UnpackScaleNormal(tex2D (_BumpMap, texcoords.xy), _BumpScale); UnpackNormal \u91c7\u6837\u51fa\u6765\u7684\u5207\u7ebf\u7a7a\u95f4\u6cd5\u5411\u91cf, \u5c06 [0, 1] \u7a7a\u95f4\u8f6c\u6362\u56de [-1, 1] , DXT5nm \u538b\u7f29\u7684\u6cd5\u7ebf\u8d34\u56fe\u53ea\u4f1a\u5b58\u50a8 xy \u503c\u6240\u4ee5\u9700\u8981\u7b97\u51fa z // Unpack normal as DXT5nm (1, y, 1, x) or BC5 (x, y, 0, 1) // Note neutral texture like \"bump\" is (0, 0, 1, 1) to work with both plain RGB normal and DXT5nm/BC5 fixed3 UnpackNormalmapRGorAG(fixed4 packednormal) { // This do the trick packednormal.x *= packednormal.w; fixed3 normal; normal.xy = packednormal.xy * 2 - 1; normal.z = sqrt(1 - saturate(dot(normal.xy, normal.xy))); return normal; } inline fixed3 UnpackNormal(fixed4 packednormal) { #if defined(UNITY_NO_DXT5nm) return packednormal.xyz * 2 - 1; #else return UnpackNormalmapRGorAG(packednormal); #endif } \u6700\u540e\u5c06 normalTangent \u8f6c\u6362\u5230\u4e16\u754c\u7a7a\u95f4\u5750\u6807\u518d\u5f52\u4e00\u5316\u5c31\u53ef\u4ee5\u4f7f\u7528\u4e86 half3 normalWorld = normalize(mul(normalTangent, tangentToWorld));","title":"Fragment"},{"location":"NormalMap/#_4","text":"odd-negative scaling : \u5947\u6570\u8f74\u8d1f\u7f29\u653e, xyz\u4e2d\u67091\u62163\u4e2a\u8f74\u7684\u7f29\u653e\u503c\u4e3a\u8d1f. \u5177\u6709 odd-negative scaling \u548c\u6ca1\u6709\u7684\u7269\u4f53\u6e32\u67d3\u72b6\u6001\u4e0d\u540c, \u56e0\u6b64\u4e5f\u4e0d\u80fd\u52a8\u6001\u5408\u6279\\ \u5728Unity\u4e2d vertex.tangent.w = 1 \u6216 -1 \u4e4b\u6240\u4ee5\u52a0\u4e86\u8fd9\u4e2a\u503c, \u662f\u56e0\u4e3a\u5728 OpenGL \u548c DirectX \u5e73\u53f0\u4e0aUV\u8d70\u5411\u4e0d\u4e00\u6837. OpenGL \u5e73\u53f0\uff0cU\u6c34\u5e73\u5411\u53f3\uff0cV\u5782\u76f4\u5411\u4e0a\u5373+y\\ DirectX \u5e73\u53f0\uff0cU\u6c34\u5e73\u5411\u53f3\uff0cV\u5782\u76f4\u5411\u4e0b\u5373-y\\ \u800cUnity\u9075\u5faa\u7684\u662f OpenGL \u89c4\u8303\uff0c\u5728\u5bfc\u5165\u6a21\u578b\u7684\u65f6\u5019uv\u8d70\u5411\u662f+y\uff0c\u6240\u4ee5\u5982\u679c\u5728windows\u4e0aUnity\u7528 DirectX \u7684\u60c5\u51b5\u4e0b\uff0c\u53c9\u4e58\u5f97\u5230\u7684 B' \u521a\u597d\u53cd\u5411\u4e86\uff0c\u624b\u6027\u9519\u8bef\u3002\u6240\u4ee5Unity\u5b58\u50a8\u4e86\u4e00\u4e2a\u624b\u6027\u4fe1\u606f\u5728 tangent.w \u91cc\uff0c\u5728\u6b63\u4ea4\u5316\u6700\u540e\u5f97\u5230\u5207\u7ebf T' \u7684\u65f6\u5019\u8ba1\u7b97\u5f53\u524d\u5e73\u53f0\u7684\u624b\u6027\u503c\u5e76\u5b58\u5728 tangent.w \u4e2d\u3002 \u6240\u4ee5\u526f\u5207\u7ebf\u7684\u8ba1\u7b97\u65f6\u624d\u4f1a *sign","title":"\u8865\u5145"},{"location":"%E5%9F%BA%E4%BA%8EMalioc%E9%9D%99%E6%80%81%E5%88%86%E6%9E%90Shader/","text":"\u57fa\u4e8eMalioc\u9759\u6001\u5206\u6790Shader Mali Offline Compiler malioc \u662f arm \u63a8\u51fa\u7684\u57fa\u4e8e mali GPU \u7684 shader \u79bb\u7ebf\u9759\u6001\u5206\u6790\u5de5\u5177. \u652f\u6301\u4ee5\u4e0bGPU \u2022 Mali-T700 series (Midgard architecture) \u2022 Mali-T800 series (Midgard architecture) \u2022 Mali\u2011G31 (Bifrost architecture) \u2022 Mali\u2011G51 and Mali\u2011G52 (Bifrost architecture) \u2022 Mali\u2011G71, Mali-G72, and Mali-G76 (Bifrost architecture) \u2022 Mali\u2011G57, Mali\u2011G68, Mali\u2011G77, and Mali\u2011G78 (Valhall architecture) \u4f7f\u7528\u65b9\u6cd5 \u547d\u4ee4\u884c\u8f93\u5165 malioc -c <target_gpu> [<shader_type>] <file1> [<file2> \u2026] [-o <file>] shader_type \u53ef\u8f93\u5165 \u2022 --vertex \u2022 --tessellation_control \u2022 --tessellation_evaluation \u2022 --geometry \u2022 --fragment \u2022 --compute \u5982\u679c file \u5df2\u7ecf\u4f7f\u7528\u4e86\u4ee5\u4e0b\u6269\u5c55\u540d\u5219\u65e0\u9700\u6307\u5b9a shader_type .vert OpenGL ES vertex shader. .tesc OpenGL ES tessellation control shader. .tese OpenGL ES tessellation evaluation shader. .geom OpenGL ES geometry shader. .frag OpenGL ES fragment shader. .comp OpenGL ES compute shader. \u7528 -D \u53ef\u4ee5\u5b9a\u4e49 Shader \u4e2d\u7684\u5b8f\u6765\u6267\u884c\u90e8\u5206\u4ee3\u7801 -Dfoo \u5b9a\u4e49foo\u4e3a1 -Dfoo=bar \u5b9a\u4e49foo\u4e3abar\u7684\u503c \u6027\u80fd\u5206\u6790 \u6267\u884c\u4ee5\u4e0b\u547d\u4ee4\u884c\u4ee3\u7801 $ malioc.exe Unlit-test-LOD100.vert \u5f97\u5230\u4ee5\u4e0b\u6027\u80fd\u6570\u636e Mali Offline Compiler v7.4.0 (Build 330167) Copyright 2007-2021 Arm Limited, all rights reserved Configuration ============= Hardware: Mali-G710 r0p0 Architecture: Valhall Driver: r32p0-00rel0 Shader type: OpenGL ES Vertex Main shader =========== Position variant ---------------- Work registers: 19 Uniform registers: 44 Stack spilling: false 16-bit arithmetic: 0% FMA CVT SFU LS T Bound Total instruction cycles: 0.25 0.00 0.00 2.00 0.00 LS Shortest path cycles: 0.25 0.00 0.00 2.00 0.00 LS Longest path cycles: 0.25 0.00 0.00 2.00 0.00 LS FMA = Arith FMA, CVT = Arith CVT, SFU = Arith SFU, LS = Load/Store, T = Texture Varying variant --------------- Work registers: 7 Uniform registers: 12 Stack spilling: false 16-bit arithmetic: 0% FMA CVT SFU LS T Bound Total instruction cycles: 0.02 0.00 0.00 3.00 0.00 LS Shortest path cycles: 0.02 0.00 0.00 3.00 0.00 LS Longest path cycles: 0.02 0.00 0.00 3.00 0.00 LS FMA = Arith FMA, CVT = Arith CVT, SFU = Arith SFU, LS = Load/Store, T = Texture Shader properties ================= Has uniform computation: false \u770b\u5230 vertex shader \u88ab\u5206\u4e3a\u4e86 Position variant \u548c Varing variant \u4e24\u6bb5. \u5728 Bifrost \u548c Valhall \u67b6\u6784\u4e0a, .vert \u4f1a\u88ab Index-Driven Vertex Shading (IDVS) \u7ba1\u7ebf\u7f16\u8bd1\u6210\u4e24\u4e2a binaries Position shader : \u53ea\u6709 position \u76f8\u5173\u8ba1\u7b97 Varying Shader : \u8ba1\u7b97\u5269\u4e0b\u7684\u6240\u6709 vertex attribute Pos shader \u5bf9\u6bcf\u4e00\u4e2a\u7d22\u5f15\u9876\u70b9\u90fd\u4f1a\u6267\u884c, Varying shader \u53ea\u5bf9\u5254\u9664\u540e\u7684\u53ef\u89c1\u56fe\u5143\u6267\u884c, \u6240\u4ee5\u8fd9\u4e24\u4e2a shader \u7684\u6570\u636e\u88ab\u5206\u5f00\u8868\u793a. \u539f\u6587: The position shader is executed for every index vertex, but the varying shader is only executed for vertices that are part of a visible primitive that survives culling. Mali Offline Compiler reports separate performance tables for each of these variants. Mali GPU \u9759\u6001\u5206\u6790\u6570\u636e\u9879 Bifrost\u67b6\u6784 Arithmetic unit (A) \u8ba1\u7b97\u5355\u5143 Load/store unit (LS) \u6267\u884c\u6240\u6709\u975eTexture\u7684\u5185\u5b58\u8bbf\u95ee, \u5305\u62ecbuffer, image\u548c\u539f\u5b50\u64cd\u4f5c Varying unit (V) \u6267\u884c\u53d8\u91cf\u63d2\u503c Texture unit (T) \u6267\u884c\u6240\u6709\u7eb9\u7406\u91c7\u6837\u548c\u8fc7\u6ee4\u64cd\u4f5c Work registers Bifrost GPU shader core \u53ef\u4ee5\u521b\u5efa\u591a\u4e2a\u7ebf\u7a0b, \u53d6\u51b3\u4e8e\u6b63\u5728\u4f7f\u7528\u7684 Shader programs \u7684 work registers \u6570\u91cf 0-32 registers : Maximum thread capacity 33-64 registers : Half thread capacity \u6240\u4ee5\u5982\u679c\u6bd4\u8d77 highp , \u5c3d\u53ef\u80fd\u4f7f\u7528\u66f4\u591a\u7684 mediump \u7684\u8bdd\u5c31\u80fd\u521b\u5efa\u66f4\u591a\u7ebf\u7a0b\u6765\u8ba9 GPU \u7684\u8d1f\u8f7d\u4e0a\u5347\u4ece\u800c\u63d0\u9ad8\u6027\u80fd Valhall \u67b6\u6784 Valhall \u67096\u79cd\u5e76\u884c\u7ba1\u7ebf, \u5176\u4e2d3\u79cd arithmetic \u7ba1\u7ebf\u548c3\u79cd fixted function support \u7ba1\u7ebf Arithmetic fused multiply accumulate unit (FMA) FMA\u7ba1\u7ebf\u6784\u5efa\u4e8616-wide warp, \u6bcf\u7ebf\u7a0b\u6bcf\u65f6\u949f\u5468\u671f\u53ef\u4ee5\u53d1\u51fa\u4e00\u4e2a32-bit\u64cd\u4f5c\u6216\u8005\u4e24\u4e2a16bit\u64cd\u4f5c The FMA pipelines are the main arithmetic pipelines, implementing the floating-point multipliers that are widely used in shader code. Each FMA pipeline implements a 16-wide warp, and can issue a single 32-bit operation or two 16-bit operations per thread and per clock cycle. Arithmetic convert unit (CVT) \u7c7b\u578b\u8f6c\u6362\u5355\u5143 The CVT pipelines implement simple operations, such as format conversion and integer addition. Arithmetic special functions unit (SFU) \u7279\u6b8a\u8fd0\u7b97\u5355\u5143, \u7528\u4e8e\u6267\u884c\u5012\u6570\u548c \u8d85\u8d8a\u51fd\u6570 . Each SFU pipeline implements a 4-wide issue path, executing a 16-wide warp over 4 clock cycles Load/store unit (LS) Varying unit (V) Texture unit (T) \u6d4b\u8bd5\u5404\u9879\u6570\u636e Texture \u91c7\u68379\u6b21 #version 300 es precision highp float; precision highp int; #define UNITY_SUPPORTS_UNIFORM_LOCATION 1 #if UNITY_SUPPORTS_UNIFORM_LOCATION #define UNITY_LOCATION(x) layout(location = x) #define UNITY_BINDING(x) layout(binding = x, std140) #else #define UNITY_LOCATION(x) #define UNITY_BINDING(x) layout(std140) #endif UNITY_LOCATION(0) uniform mediump sampler2D _MainTex; in highp vec2 vs_TEXCOORD0; layout(location = 0) out mediump vec4 SV_Target0; vec4 u_xlat0; mediump vec4 u_xlat16_0; vec4 u_xlat1; mediump vec4 u_xlat16_1; mediump vec4 u_xlat16_2; void main() { u_xlat0 = vs_TEXCOORD0.xyxy + vec4(-1.0, 1.0, 0.0, 1.0); u_xlat16_1 = texture(_MainTex, u_xlat0.xy); u_xlat16_0 = texture(_MainTex, u_xlat0.zw); u_xlat0 = u_xlat16_0 + u_xlat16_1; u_xlat1 = vs_TEXCOORD0.xyxy + vec4(1.0, 1.0, -1.0, 0.0); u_xlat16_2 = texture(_MainTex, u_xlat1.xy); u_xlat16_1 = texture(_MainTex, u_xlat1.zw); u_xlat0 = u_xlat0 + u_xlat16_2; u_xlat0 = u_xlat16_1 + u_xlat0; u_xlat16_1 = texture(_MainTex, vs_TEXCOORD0.xy); u_xlat0 = u_xlat0 + u_xlat16_1; u_xlat1 = vs_TEXCOORD0.xyxy + vec4(1.0, 0.0, -1.0, -1.0); u_xlat16_2 = texture(_MainTex, u_xlat1.xy); u_xlat16_1 = texture(_MainTex, u_xlat1.zw); u_xlat0 = u_xlat0 + u_xlat16_2; u_xlat0 = u_xlat16_1 + u_xlat0; u_xlat1 = vs_TEXCOORD0.xyxy + vec4(0.0, -1.0, 1.0, -1.0); u_xlat16_2 = texture(_MainTex, u_xlat1.xy); u_xlat16_1 = texture(_MainTex, u_xlat1.zw); u_xlat0 = u_xlat0 + u_xlat16_2; u_xlat0 = u_xlat16_1 + u_xlat0; SV_Target0 = u_xlat0 * vec4(0.111111112, 0.111111112, 0.111111112, 0.111111112); return; } \u5206\u6790\u7ed3\u679c Load & Store","title":"Shader\u9759\u6001\u5206\u6790"},{"location":"%E5%9F%BA%E4%BA%8EMalioc%E9%9D%99%E6%80%81%E5%88%86%E6%9E%90Shader/#maliocshader","text":"","title":"\u57fa\u4e8eMalioc\u9759\u6001\u5206\u6790Shader"},{"location":"%E5%9F%BA%E4%BA%8EMalioc%E9%9D%99%E6%80%81%E5%88%86%E6%9E%90Shader/#mali-offline-compiler","text":"malioc \u662f arm \u63a8\u51fa\u7684\u57fa\u4e8e mali GPU \u7684 shader \u79bb\u7ebf\u9759\u6001\u5206\u6790\u5de5\u5177. \u652f\u6301\u4ee5\u4e0bGPU \u2022 Mali-T700 series (Midgard architecture) \u2022 Mali-T800 series (Midgard architecture) \u2022 Mali\u2011G31 (Bifrost architecture) \u2022 Mali\u2011G51 and Mali\u2011G52 (Bifrost architecture) \u2022 Mali\u2011G71, Mali-G72, and Mali-G76 (Bifrost architecture) \u2022 Mali\u2011G57, Mali\u2011G68, Mali\u2011G77, and Mali\u2011G78 (Valhall architecture)","title":"Mali Offline Compiler"},{"location":"%E5%9F%BA%E4%BA%8EMalioc%E9%9D%99%E6%80%81%E5%88%86%E6%9E%90Shader/#_1","text":"\u547d\u4ee4\u884c\u8f93\u5165 malioc -c <target_gpu> [<shader_type>] <file1> [<file2> \u2026] [-o <file>] shader_type \u53ef\u8f93\u5165 \u2022 --vertex \u2022 --tessellation_control \u2022 --tessellation_evaluation \u2022 --geometry \u2022 --fragment \u2022 --compute \u5982\u679c file \u5df2\u7ecf\u4f7f\u7528\u4e86\u4ee5\u4e0b\u6269\u5c55\u540d\u5219\u65e0\u9700\u6307\u5b9a shader_type .vert OpenGL ES vertex shader. .tesc OpenGL ES tessellation control shader. .tese OpenGL ES tessellation evaluation shader. .geom OpenGL ES geometry shader. .frag OpenGL ES fragment shader. .comp OpenGL ES compute shader. \u7528 -D \u53ef\u4ee5\u5b9a\u4e49 Shader \u4e2d\u7684\u5b8f\u6765\u6267\u884c\u90e8\u5206\u4ee3\u7801 -Dfoo \u5b9a\u4e49foo\u4e3a1 -Dfoo=bar \u5b9a\u4e49foo\u4e3abar\u7684\u503c","title":"\u4f7f\u7528\u65b9\u6cd5"},{"location":"%E5%9F%BA%E4%BA%8EMalioc%E9%9D%99%E6%80%81%E5%88%86%E6%9E%90Shader/#_2","text":"\u6267\u884c\u4ee5\u4e0b\u547d\u4ee4\u884c\u4ee3\u7801 $ malioc.exe Unlit-test-LOD100.vert \u5f97\u5230\u4ee5\u4e0b\u6027\u80fd\u6570\u636e Mali Offline Compiler v7.4.0 (Build 330167) Copyright 2007-2021 Arm Limited, all rights reserved Configuration ============= Hardware: Mali-G710 r0p0 Architecture: Valhall Driver: r32p0-00rel0 Shader type: OpenGL ES Vertex Main shader =========== Position variant ---------------- Work registers: 19 Uniform registers: 44 Stack spilling: false 16-bit arithmetic: 0% FMA CVT SFU LS T Bound Total instruction cycles: 0.25 0.00 0.00 2.00 0.00 LS Shortest path cycles: 0.25 0.00 0.00 2.00 0.00 LS Longest path cycles: 0.25 0.00 0.00 2.00 0.00 LS FMA = Arith FMA, CVT = Arith CVT, SFU = Arith SFU, LS = Load/Store, T = Texture Varying variant --------------- Work registers: 7 Uniform registers: 12 Stack spilling: false 16-bit arithmetic: 0% FMA CVT SFU LS T Bound Total instruction cycles: 0.02 0.00 0.00 3.00 0.00 LS Shortest path cycles: 0.02 0.00 0.00 3.00 0.00 LS Longest path cycles: 0.02 0.00 0.00 3.00 0.00 LS FMA = Arith FMA, CVT = Arith CVT, SFU = Arith SFU, LS = Load/Store, T = Texture Shader properties ================= Has uniform computation: false \u770b\u5230 vertex shader \u88ab\u5206\u4e3a\u4e86 Position variant \u548c Varing variant \u4e24\u6bb5. \u5728 Bifrost \u548c Valhall \u67b6\u6784\u4e0a, .vert \u4f1a\u88ab Index-Driven Vertex Shading (IDVS) \u7ba1\u7ebf\u7f16\u8bd1\u6210\u4e24\u4e2a binaries Position shader : \u53ea\u6709 position \u76f8\u5173\u8ba1\u7b97 Varying Shader : \u8ba1\u7b97\u5269\u4e0b\u7684\u6240\u6709 vertex attribute Pos shader \u5bf9\u6bcf\u4e00\u4e2a\u7d22\u5f15\u9876\u70b9\u90fd\u4f1a\u6267\u884c, Varying shader \u53ea\u5bf9\u5254\u9664\u540e\u7684\u53ef\u89c1\u56fe\u5143\u6267\u884c, \u6240\u4ee5\u8fd9\u4e24\u4e2a shader \u7684\u6570\u636e\u88ab\u5206\u5f00\u8868\u793a. \u539f\u6587: The position shader is executed for every index vertex, but the varying shader is only executed for vertices that are part of a visible primitive that survives culling. Mali Offline Compiler reports separate performance tables for each of these variants.","title":"\u6027\u80fd\u5206\u6790"},{"location":"%E5%9F%BA%E4%BA%8EMalioc%E9%9D%99%E6%80%81%E5%88%86%E6%9E%90Shader/#mali-gpu","text":"","title":"Mali GPU \u9759\u6001\u5206\u6790\u6570\u636e\u9879"},{"location":"%E5%9F%BA%E4%BA%8EMalioc%E9%9D%99%E6%80%81%E5%88%86%E6%9E%90Shader/#bifrost","text":"Arithmetic unit (A) \u8ba1\u7b97\u5355\u5143 Load/store unit (LS) \u6267\u884c\u6240\u6709\u975eTexture\u7684\u5185\u5b58\u8bbf\u95ee, \u5305\u62ecbuffer, image\u548c\u539f\u5b50\u64cd\u4f5c Varying unit (V) \u6267\u884c\u53d8\u91cf\u63d2\u503c Texture unit (T) \u6267\u884c\u6240\u6709\u7eb9\u7406\u91c7\u6837\u548c\u8fc7\u6ee4\u64cd\u4f5c","title":"Bifrost\u67b6\u6784"},{"location":"%E5%9F%BA%E4%BA%8EMalioc%E9%9D%99%E6%80%81%E5%88%86%E6%9E%90Shader/#work-registers","text":"Bifrost GPU shader core \u53ef\u4ee5\u521b\u5efa\u591a\u4e2a\u7ebf\u7a0b, \u53d6\u51b3\u4e8e\u6b63\u5728\u4f7f\u7528\u7684 Shader programs \u7684 work registers \u6570\u91cf 0-32 registers : Maximum thread capacity 33-64 registers : Half thread capacity \u6240\u4ee5\u5982\u679c\u6bd4\u8d77 highp , \u5c3d\u53ef\u80fd\u4f7f\u7528\u66f4\u591a\u7684 mediump \u7684\u8bdd\u5c31\u80fd\u521b\u5efa\u66f4\u591a\u7ebf\u7a0b\u6765\u8ba9 GPU \u7684\u8d1f\u8f7d\u4e0a\u5347\u4ece\u800c\u63d0\u9ad8\u6027\u80fd","title":"Work registers"},{"location":"%E5%9F%BA%E4%BA%8EMalioc%E9%9D%99%E6%80%81%E5%88%86%E6%9E%90Shader/#valhall","text":"Valhall \u67096\u79cd\u5e76\u884c\u7ba1\u7ebf, \u5176\u4e2d3\u79cd arithmetic \u7ba1\u7ebf\u548c3\u79cd fixted function support \u7ba1\u7ebf Arithmetic fused multiply accumulate unit (FMA) FMA\u7ba1\u7ebf\u6784\u5efa\u4e8616-wide warp, \u6bcf\u7ebf\u7a0b\u6bcf\u65f6\u949f\u5468\u671f\u53ef\u4ee5\u53d1\u51fa\u4e00\u4e2a32-bit\u64cd\u4f5c\u6216\u8005\u4e24\u4e2a16bit\u64cd\u4f5c The FMA pipelines are the main arithmetic pipelines, implementing the floating-point multipliers that are widely used in shader code. Each FMA pipeline implements a 16-wide warp, and can issue a single 32-bit operation or two 16-bit operations per thread and per clock cycle. Arithmetic convert unit (CVT) \u7c7b\u578b\u8f6c\u6362\u5355\u5143 The CVT pipelines implement simple operations, such as format conversion and integer addition. Arithmetic special functions unit (SFU) \u7279\u6b8a\u8fd0\u7b97\u5355\u5143, \u7528\u4e8e\u6267\u884c\u5012\u6570\u548c \u8d85\u8d8a\u51fd\u6570 . Each SFU pipeline implements a 4-wide issue path, executing a 16-wide warp over 4 clock cycles Load/store unit (LS) Varying unit (V) Texture unit (T)","title":"Valhall \u67b6\u6784"},{"location":"%E5%9F%BA%E4%BA%8EMalioc%E9%9D%99%E6%80%81%E5%88%86%E6%9E%90Shader/#_3","text":"","title":"\u6d4b\u8bd5\u5404\u9879\u6570\u636e"},{"location":"%E5%9F%BA%E4%BA%8EMalioc%E9%9D%99%E6%80%81%E5%88%86%E6%9E%90Shader/#texture","text":"\u91c7\u68379\u6b21 #version 300 es precision highp float; precision highp int; #define UNITY_SUPPORTS_UNIFORM_LOCATION 1 #if UNITY_SUPPORTS_UNIFORM_LOCATION #define UNITY_LOCATION(x) layout(location = x) #define UNITY_BINDING(x) layout(binding = x, std140) #else #define UNITY_LOCATION(x) #define UNITY_BINDING(x) layout(std140) #endif UNITY_LOCATION(0) uniform mediump sampler2D _MainTex; in highp vec2 vs_TEXCOORD0; layout(location = 0) out mediump vec4 SV_Target0; vec4 u_xlat0; mediump vec4 u_xlat16_0; vec4 u_xlat1; mediump vec4 u_xlat16_1; mediump vec4 u_xlat16_2; void main() { u_xlat0 = vs_TEXCOORD0.xyxy + vec4(-1.0, 1.0, 0.0, 1.0); u_xlat16_1 = texture(_MainTex, u_xlat0.xy); u_xlat16_0 = texture(_MainTex, u_xlat0.zw); u_xlat0 = u_xlat16_0 + u_xlat16_1; u_xlat1 = vs_TEXCOORD0.xyxy + vec4(1.0, 1.0, -1.0, 0.0); u_xlat16_2 = texture(_MainTex, u_xlat1.xy); u_xlat16_1 = texture(_MainTex, u_xlat1.zw); u_xlat0 = u_xlat0 + u_xlat16_2; u_xlat0 = u_xlat16_1 + u_xlat0; u_xlat16_1 = texture(_MainTex, vs_TEXCOORD0.xy); u_xlat0 = u_xlat0 + u_xlat16_1; u_xlat1 = vs_TEXCOORD0.xyxy + vec4(1.0, 0.0, -1.0, -1.0); u_xlat16_2 = texture(_MainTex, u_xlat1.xy); u_xlat16_1 = texture(_MainTex, u_xlat1.zw); u_xlat0 = u_xlat0 + u_xlat16_2; u_xlat0 = u_xlat16_1 + u_xlat0; u_xlat1 = vs_TEXCOORD0.xyxy + vec4(0.0, -1.0, 1.0, -1.0); u_xlat16_2 = texture(_MainTex, u_xlat1.xy); u_xlat16_1 = texture(_MainTex, u_xlat1.zw); u_xlat0 = u_xlat0 + u_xlat16_2; u_xlat0 = u_xlat16_1 + u_xlat0; SV_Target0 = u_xlat0 * vec4(0.111111112, 0.111111112, 0.111111112, 0.111111112); return; } \u5206\u6790\u7ed3\u679c","title":"Texture"},{"location":"%E5%9F%BA%E4%BA%8EMalioc%E9%9D%99%E6%80%81%E5%88%86%E6%9E%90Shader/#load-store","text":"","title":"Load &amp; Store"}]}