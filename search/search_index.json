{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"\u56fe\u5f62\u5b66\u7b14\u8bb0 \u5c06\u4e4b\u524d\u7684\u56fe\u5f62\u5b66\u7b14\u8bb0\u5148\u642c\u79fb\u5230github pages\u4e0a\u597d\u4e86, \u628a\u8bb0\u5f55\u7684\u4e60\u60ef\u575a\u6301\u4e0b\u53bb, \u5b9a\u671f\u68b3\u7406~","title":"\u4e3b\u9875"},{"location":"#_1","text":"\u5c06\u4e4b\u524d\u7684\u56fe\u5f62\u5b66\u7b14\u8bb0\u5148\u642c\u79fb\u5230github pages\u4e0a\u597d\u4e86, \u628a\u8bb0\u5f55\u7684\u4e60\u60ef\u575a\u6301\u4e0b\u53bb, \u5b9a\u671f\u68b3\u7406~","title":"\u56fe\u5f62\u5b66\u7b14\u8bb0"},{"location":"NormalMap/","text":"\u6cd5\u7ebf\u8d34\u56fe \u6cd5\u7ebf\u8d34\u56fe\u8868\u793a\u7684\u662f\u5207\u7ebf\u7a7a\u95f4\u4e0b\u7684\u6cd5\u5411\u91cf, \u4efb\u4f55\u671d\u5411\u7684\u5e73\u9762\u90fd\u53ef\u4ee5\u9002\u7528\u540c\u4e00\u5957\u6cd5\u7ebf\u8d34\u56fe. \u4f7f\u7528 \u9876\u70b9\u6570\u636e \u9876\u70b9\u6570\u636e\u9664\u4e86 pos , texcoord , normal \u5916\u8fd8\u9700 Tangent \u6216 Bitangent . VS vs\u4e2d\u5efa\u7acbTBN\u77e9\u9635, \u7528\u4e8e\u5c06\u5207\u7ebf\u7a7a\u95f4\u7684\u6cd5\u7ebf\u8f6c\u5230\u4e16\u754c\u7a7a\u95f4\u4fbf\u4e8e\u540e\u7eed\u5149\u7167\u8ba1\u7b97 // \u5c06\u5207\u7ebf\u4ece\u6a21\u578b\u7a7a\u95f4\u8f6c\u5230\u4e16\u754c\u7a7a\u95f4 half4 tangentWorld = half4(UnityObjectToWorldDir(v.tangent.xyz), v.tangent.w); half3x3 tangentToWorld = CreateTangentToWorldPerVertex(normalWorld, tangentWorld.xyz, tangentWorld.w); // Unity\u6784\u5efaTBN\u77e9\u9635\u7684\u51fd\u6570 half3x3 CreateTangentToWorldPerVertex(half3 normal, half3 tangent, half tangentSign) { // For odd-negative scale transforms we need to flip the sign half sign = tangentSign * unity_WorldTransformParams.w; half3 binormal = cross(normal, tangent) * sign; return half3x3(tangent, binormal, normal); } Fragment half3 normalTangent = UnpackScaleNormal(tex2D (_BumpMap, texcoords.xy), _BumpScale); UnpackNormal \u91c7\u6837\u51fa\u6765\u7684\u5207\u7ebf\u7a7a\u95f4\u6cd5\u5411\u91cf, \u5c06 [0, 1] \u7a7a\u95f4\u8f6c\u6362\u56de [-1, 1] , DXT5nm \u538b\u7f29\u7684\u6cd5\u7ebf\u8d34\u56fe\u53ea\u4f1a\u5b58\u50a8 xy \u503c\u6240\u4ee5\u9700\u8981\u7b97\u51fa z // Unpack normal as DXT5nm (1, y, 1, x) or BC5 (x, y, 0, 1) // Note neutral texture like \"bump\" is (0, 0, 1, 1) to work with both plain RGB normal and DXT5nm/BC5 fixed3 UnpackNormalmapRGorAG(fixed4 packednormal) { // This do the trick packednormal.x *= packednormal.w; fixed3 normal; normal.xy = packednormal.xy * 2 - 1; normal.z = sqrt(1 - saturate(dot(normal.xy, normal.xy))); return normal; } inline fixed3 UnpackNormal(fixed4 packednormal) { #if defined(UNITY_NO_DXT5nm) return packednormal.xyz * 2 - 1; #else return UnpackNormalmapRGorAG(packednormal); #endif } \u6700\u540e\u5c06 normalTangent \u8f6c\u6362\u5230\u4e16\u754c\u7a7a\u95f4\u5750\u6807\u518d\u5f52\u4e00\u5316\u5c31\u53ef\u4ee5\u4f7f\u7528\u4e86 half3 normalWorld = normalize(mul(normalTangent, tangentToWorld)); \u8865\u5145 odd-negative scaling : \u5947\u6570\u8f74\u8d1f\u7f29\u653e, xyz\u4e2d\u67091\u62163\u4e2a\u8f74\u7684\u7f29\u653e\u503c\u4e3a\u8d1f. \u5177\u6709 odd-negative scaling \u548c\u6ca1\u6709\u7684\u7269\u4f53\u6e32\u67d3\u72b6\u6001\u4e0d\u540c, \u56e0\u6b64\u4e5f\u4e0d\u80fd\u52a8\u6001\u5408\u6279\\ \u5728Unity\u4e2d vertex.tangent.w = 1 \u6216 -1 \u4e4b\u6240\u4ee5\u52a0\u4e86\u8fd9\u4e2a\u503c, \u662f\u56e0\u4e3a\u5728 OpenGL \u548c DirectX \u5e73\u53f0\u4e0aUV\u8d70\u5411\u4e0d\u4e00\u6837. OpenGL \u5e73\u53f0\uff0cU\u6c34\u5e73\u5411\u53f3\uff0cV\u5782\u76f4\u5411\u4e0a\u5373+y\\ DirectX \u5e73\u53f0\uff0cU\u6c34\u5e73\u5411\u53f3\uff0cV\u5782\u76f4\u5411\u4e0b\u5373-y\\ \u800cUnity\u9075\u5faa\u7684\u662f OpenGL \u89c4\u8303\uff0c\u5728\u5bfc\u5165\u6a21\u578b\u7684\u65f6\u5019uv\u8d70\u5411\u662f+y\uff0c\u6240\u4ee5\u5982\u679c\u5728windows\u4e0aUnity\u7528 DirectX \u7684\u60c5\u51b5\u4e0b\uff0c\u53c9\u4e58\u5f97\u5230\u7684 B' \u521a\u597d\u53cd\u5411\u4e86\uff0c\u624b\u6027\u9519\u8bef\u3002\u6240\u4ee5Unity\u5b58\u50a8\u4e86\u4e00\u4e2a\u624b\u6027\u4fe1\u606f\u5728 tangent.w \u91cc\uff0c\u5728\u6b63\u4ea4\u5316\u6700\u540e\u5f97\u5230\u5207\u7ebf T' \u7684\u65f6\u5019\u8ba1\u7b97\u5f53\u524d\u5e73\u53f0\u7684\u624b\u6027\u503c\u5e76\u5b58\u5728 tangent.w \u4e2d\u3002 \u6240\u4ee5\u526f\u5207\u7ebf\u7684\u8ba1\u7b97\u65f6\u624d\u4f1a *sign","title":"\u6cd5\u7ebf\u7eb9\u7406"},{"location":"NormalMap/#_1","text":"\u6cd5\u7ebf\u8d34\u56fe\u8868\u793a\u7684\u662f\u5207\u7ebf\u7a7a\u95f4\u4e0b\u7684\u6cd5\u5411\u91cf, \u4efb\u4f55\u671d\u5411\u7684\u5e73\u9762\u90fd\u53ef\u4ee5\u9002\u7528\u540c\u4e00\u5957\u6cd5\u7ebf\u8d34\u56fe.","title":"\u6cd5\u7ebf\u8d34\u56fe"},{"location":"NormalMap/#_2","text":"","title":"\u4f7f\u7528"},{"location":"NormalMap/#_3","text":"\u9876\u70b9\u6570\u636e\u9664\u4e86 pos , texcoord , normal \u5916\u8fd8\u9700 Tangent \u6216 Bitangent .","title":"\u9876\u70b9\u6570\u636e"},{"location":"NormalMap/#vs","text":"vs\u4e2d\u5efa\u7acbTBN\u77e9\u9635, \u7528\u4e8e\u5c06\u5207\u7ebf\u7a7a\u95f4\u7684\u6cd5\u7ebf\u8f6c\u5230\u4e16\u754c\u7a7a\u95f4\u4fbf\u4e8e\u540e\u7eed\u5149\u7167\u8ba1\u7b97 // \u5c06\u5207\u7ebf\u4ece\u6a21\u578b\u7a7a\u95f4\u8f6c\u5230\u4e16\u754c\u7a7a\u95f4 half4 tangentWorld = half4(UnityObjectToWorldDir(v.tangent.xyz), v.tangent.w); half3x3 tangentToWorld = CreateTangentToWorldPerVertex(normalWorld, tangentWorld.xyz, tangentWorld.w); // Unity\u6784\u5efaTBN\u77e9\u9635\u7684\u51fd\u6570 half3x3 CreateTangentToWorldPerVertex(half3 normal, half3 tangent, half tangentSign) { // For odd-negative scale transforms we need to flip the sign half sign = tangentSign * unity_WorldTransformParams.w; half3 binormal = cross(normal, tangent) * sign; return half3x3(tangent, binormal, normal); }","title":"VS"},{"location":"NormalMap/#fragment","text":"half3 normalTangent = UnpackScaleNormal(tex2D (_BumpMap, texcoords.xy), _BumpScale); UnpackNormal \u91c7\u6837\u51fa\u6765\u7684\u5207\u7ebf\u7a7a\u95f4\u6cd5\u5411\u91cf, \u5c06 [0, 1] \u7a7a\u95f4\u8f6c\u6362\u56de [-1, 1] , DXT5nm \u538b\u7f29\u7684\u6cd5\u7ebf\u8d34\u56fe\u53ea\u4f1a\u5b58\u50a8 xy \u503c\u6240\u4ee5\u9700\u8981\u7b97\u51fa z // Unpack normal as DXT5nm (1, y, 1, x) or BC5 (x, y, 0, 1) // Note neutral texture like \"bump\" is (0, 0, 1, 1) to work with both plain RGB normal and DXT5nm/BC5 fixed3 UnpackNormalmapRGorAG(fixed4 packednormal) { // This do the trick packednormal.x *= packednormal.w; fixed3 normal; normal.xy = packednormal.xy * 2 - 1; normal.z = sqrt(1 - saturate(dot(normal.xy, normal.xy))); return normal; } inline fixed3 UnpackNormal(fixed4 packednormal) { #if defined(UNITY_NO_DXT5nm) return packednormal.xyz * 2 - 1; #else return UnpackNormalmapRGorAG(packednormal); #endif } \u6700\u540e\u5c06 normalTangent \u8f6c\u6362\u5230\u4e16\u754c\u7a7a\u95f4\u5750\u6807\u518d\u5f52\u4e00\u5316\u5c31\u53ef\u4ee5\u4f7f\u7528\u4e86 half3 normalWorld = normalize(mul(normalTangent, tangentToWorld));","title":"Fragment"},{"location":"NormalMap/#_4","text":"odd-negative scaling : \u5947\u6570\u8f74\u8d1f\u7f29\u653e, xyz\u4e2d\u67091\u62163\u4e2a\u8f74\u7684\u7f29\u653e\u503c\u4e3a\u8d1f. \u5177\u6709 odd-negative scaling \u548c\u6ca1\u6709\u7684\u7269\u4f53\u6e32\u67d3\u72b6\u6001\u4e0d\u540c, \u56e0\u6b64\u4e5f\u4e0d\u80fd\u52a8\u6001\u5408\u6279\\ \u5728Unity\u4e2d vertex.tangent.w = 1 \u6216 -1 \u4e4b\u6240\u4ee5\u52a0\u4e86\u8fd9\u4e2a\u503c, \u662f\u56e0\u4e3a\u5728 OpenGL \u548c DirectX \u5e73\u53f0\u4e0aUV\u8d70\u5411\u4e0d\u4e00\u6837. OpenGL \u5e73\u53f0\uff0cU\u6c34\u5e73\u5411\u53f3\uff0cV\u5782\u76f4\u5411\u4e0a\u5373+y\\ DirectX \u5e73\u53f0\uff0cU\u6c34\u5e73\u5411\u53f3\uff0cV\u5782\u76f4\u5411\u4e0b\u5373-y\\ \u800cUnity\u9075\u5faa\u7684\u662f OpenGL \u89c4\u8303\uff0c\u5728\u5bfc\u5165\u6a21\u578b\u7684\u65f6\u5019uv\u8d70\u5411\u662f+y\uff0c\u6240\u4ee5\u5982\u679c\u5728windows\u4e0aUnity\u7528 DirectX \u7684\u60c5\u51b5\u4e0b\uff0c\u53c9\u4e58\u5f97\u5230\u7684 B' \u521a\u597d\u53cd\u5411\u4e86\uff0c\u624b\u6027\u9519\u8bef\u3002\u6240\u4ee5Unity\u5b58\u50a8\u4e86\u4e00\u4e2a\u624b\u6027\u4fe1\u606f\u5728 tangent.w \u91cc\uff0c\u5728\u6b63\u4ea4\u5316\u6700\u540e\u5f97\u5230\u5207\u7ebf T' \u7684\u65f6\u5019\u8ba1\u7b97\u5f53\u524d\u5e73\u53f0\u7684\u624b\u6027\u503c\u5e76\u5b58\u5728 tangent.w \u4e2d\u3002 \u6240\u4ee5\u526f\u5207\u7ebf\u7684\u8ba1\u7b97\u65f6\u624d\u4f1a *sign","title":"\u8865\u5145"},{"location":"%E5%9F%BA%E4%BA%8EMalioc%E9%9D%99%E6%80%81%E5%88%86%E6%9E%90Shader/","text":"\u57fa\u4e8eMalioc\u9759\u6001\u5206\u6790Shader Mali Offline Compiler malioc \u662f arm \u63a8\u51fa\u7684\u57fa\u4e8e mali GPU \u7684 shader \u79bb\u7ebf\u9759\u6001\u5206\u6790\u5de5\u5177. \u652f\u6301\u4ee5\u4e0bGPU \u2022 Mali-T700 series (Midgard architecture) \u2022 Mali-T800 series (Midgard architecture) \u2022 Mali\u2011G31 (Bifrost architecture) \u2022 Mali\u2011G51 and Mali\u2011G52 (Bifrost architecture) \u2022 Mali\u2011G71, Mali-G72, and Mali-G76 (Bifrost architecture) \u2022 Mali\u2011G57, Mali\u2011G68, Mali\u2011G77, and Mali\u2011G78 (Valhall architecture) \u4f7f\u7528\u65b9\u6cd5 \u547d\u4ee4\u884c\u8f93\u5165 malioc -c <target_gpu> [<shader_type>] <file1> [<file2> \u2026] [-o <file>] shader_type \u53ef\u8f93\u5165 \u2022 --vertex \u2022 --tessellation_control \u2022 --tessellation_evaluation \u2022 --geometry \u2022 --fragment \u2022 --compute \u5982\u679c file \u5df2\u7ecf\u4f7f\u7528\u4e86\u4ee5\u4e0b\u6269\u5c55\u540d\u5219\u65e0\u9700\u6307\u5b9a shader_type .vert OpenGL ES vertex shader. .tesc OpenGL ES tessellation control shader. .tese OpenGL ES tessellation evaluation shader. .geom OpenGL ES geometry shader. .frag OpenGL ES fragment shader. .comp OpenGL ES compute shader. \u7528 -D \u53ef\u4ee5\u5b9a\u4e49 Shader \u4e2d\u7684\u5b8f\u6765\u6267\u884c\u90e8\u5206\u4ee3\u7801 -Dfoo \u5b9a\u4e49foo\u4e3a1 -Dfoo=bar \u5b9a\u4e49foo\u4e3abar\u7684\u503c \u6027\u80fd\u5206\u6790 \u6267\u884c\u4ee5\u4e0b\u547d\u4ee4\u884c\u4ee3\u7801 $ malioc.exe Unlit-test-LOD100.vert \u5f97\u5230\u4ee5\u4e0b\u6027\u80fd\u6570\u636e Mali Offline Compiler v7.4.0 (Build 330167) Copyright 2007-2021 Arm Limited, all rights reserved Configuration ============= Hardware: Mali-G710 r0p0 Architecture: Valhall Driver: r32p0-00rel0 Shader type: OpenGL ES Vertex Main shader =========== Position variant ---------------- Work registers: 19 Uniform registers: 44 Stack spilling: false 16-bit arithmetic: 0% FMA CVT SFU LS T Bound Total instruction cycles: 0.25 0.00 0.00 2.00 0.00 LS Shortest path cycles: 0.25 0.00 0.00 2.00 0.00 LS Longest path cycles: 0.25 0.00 0.00 2.00 0.00 LS FMA = Arith FMA, CVT = Arith CVT, SFU = Arith SFU, LS = Load/Store, T = Texture Varying variant --------------- Work registers: 7 Uniform registers: 12 Stack spilling: false 16-bit arithmetic: 0% FMA CVT SFU LS T Bound Total instruction cycles: 0.02 0.00 0.00 3.00 0.00 LS Shortest path cycles: 0.02 0.00 0.00 3.00 0.00 LS Longest path cycles: 0.02 0.00 0.00 3.00 0.00 LS FMA = Arith FMA, CVT = Arith CVT, SFU = Arith SFU, LS = Load/Store, T = Texture Shader properties ================= Has uniform computation: false \u770b\u5230 vertex shader \u88ab\u5206\u4e3a\u4e86 Position variant \u548c Varing variant \u4e24\u6bb5. \u5728 Bifrost \u548c Valhall \u67b6\u6784\u4e0a, .vert \u4f1a\u88ab Index-Driven Vertex Shading (IDVS) \u7ba1\u7ebf\u7f16\u8bd1\u6210\u4e24\u4e2a binaries Position shader : \u53ea\u6709 position \u76f8\u5173\u8ba1\u7b97 Varying Shader : \u8ba1\u7b97\u5269\u4e0b\u7684\u6240\u6709 vertex attribute Pos shader \u5bf9\u6bcf\u4e00\u4e2a\u7d22\u5f15\u9876\u70b9\u90fd\u4f1a\u6267\u884c, Varying shader \u53ea\u5bf9\u5254\u9664\u540e\u7684\u53ef\u89c1\u56fe\u5143\u6267\u884c, \u6240\u4ee5\u8fd9\u4e24\u4e2a shader \u7684\u6570\u636e\u88ab\u5206\u5f00\u8868\u793a. \u539f\u6587: The position shader is executed for every index vertex, but the varying shader is only executed for vertices that are part of a visible primitive that survives culling. Mali Offline Compiler reports separate performance tables for each of these variants. Mali GPU \u9759\u6001\u5206\u6790\u6570\u636e\u9879 Bifrost\u67b6\u6784 Arithmetic unit (A) \u8ba1\u7b97\u5355\u5143 Load/store unit (LS) \u6267\u884c\u6240\u6709\u975eTexture\u7684\u5185\u5b58\u8bbf\u95ee, \u5305\u62ecbuffer, image\u548c\u539f\u5b50\u64cd\u4f5c, \u53d7 vertex \u7684\u7ed3\u6784\u5927\u5c0f\u5f71\u54cd Varying unit (V) \u6267\u884c\u53d8\u91cf\u63d2\u503c, \u53d7 struct v2f \u5927\u5c0f\u5f71\u54cd Texture unit (T) \u6267\u884c\u6240\u6709\u7eb9\u7406\u91c7\u6837\u548c\u8fc7\u6ee4\u64cd\u4f5c Work registers Bifrost GPU shader core \u53ef\u4ee5\u521b\u5efa\u591a\u4e2a\u7ebf\u7a0b, \u53d6\u51b3\u4e8e\u6b63\u5728\u4f7f\u7528\u7684 Shader programs \u7684 work registers \u6570\u91cf 0-32 registers : Maximum thread capacity 33-64 registers : Half thread capacity \u6240\u4ee5\u5982\u679c\u6bd4\u8d77 highp , \u5c3d\u53ef\u80fd\u4f7f\u7528\u66f4\u591a\u7684 mediump \u7684\u8bdd\u5c31\u80fd\u521b\u5efa\u66f4\u591a\u7ebf\u7a0b\u6765\u8ba9 GPU \u7684\u8d1f\u8f7d\u4e0a\u5347\u4ece\u800c\u63d0\u9ad8\u6027\u80fd Valhall \u67b6\u6784 Valhall \u67096\u79cd\u5e76\u884c\u7ba1\u7ebf, \u5176\u4e2d3\u79cd arithmetic \u7ba1\u7ebf\u548c3\u79cd fixted function support \u7ba1\u7ebf Arithmetic fused multiply accumulate unit (FMA) FMA\u7ba1\u7ebf\u6784\u5efa\u4e8616-wide warp, \u6bcf\u7ebf\u7a0b\u6bcf\u65f6\u949f\u5468\u671f\u53ef\u4ee5\u53d1\u51fa\u4e00\u4e2a32-bit\u64cd\u4f5c\u6216\u8005\u4e24\u4e2a16bit\u64cd\u4f5c The FMA pipelines are the main arithmetic pipelines, implementing the floating-point multipliers that are widely used in shader code. Each FMA pipeline implements a 16-wide warp, and can issue a single 32-bit operation or two 16-bit operations per thread and per clock cycle. Arithmetic convert unit (CVT) \u7c7b\u578b\u8f6c\u6362\u5355\u5143 The CVT pipelines implement simple operations, such as format conversion and integer addition. Arithmetic special functions unit (SFU) \u7279\u6b8a\u8fd0\u7b97\u5355\u5143, \u7528\u4e8e\u6267\u884c\u5012\u6570\u548c \u8d85\u8d8a\u51fd\u6570 . Each SFU pipeline implements a 4-wide issue path, executing a 16-wide warp over 4 clock cycles Load/store unit (LS) Varying unit (V) Texture unit (T) \u6d4b\u8bd5\u5404\u9879\u6570\u636e 1. \u57fa\u51c6Shader \u4ee5\u6700\u57fa\u7840\u7684shader, \u9876\u70b9\u53ea\u6709pos\u548cuv, \u4e14\u91c7\u6837\u4e00\u6b21\u7eb9\u7406\u5e76\u8f93\u51fa\u7ed3\u679c\u4f5c\u4e3a\u57fa\u51c6shader. \u518d\u6dfb\u52a0\u5176\u5b83\u4ee3\u7801\u89c2\u5bdf\u5404\u9879\u6570\u636e\u7684\u53d8\u5316 \u4ee3\u7801\uff08\u70b9\u51fb\uff09 Shader \"Unlit/benchShader\" { Properties { _MainTex (\"Texture\", 2D) = \"white\" {} } SubShader { Tags { \"RenderType\"=\"Opaque\" } LOD 100 Pass { CGPROGRAM #pragma vertex vert #pragma fragment frag #include \"UnityCG.cginc\" struct appdata { float4 vertex : POSITION; float2 uv : TEXCOORD0; }; struct v2f { float2 uv : TEXCOORD0; float4 vertex : SV_POSITION; }; sampler2D _MainTex; float4 _MainTex_ST; v2f vert (appdata v) { v2f o; o.vertex = UnityObjectToClipPos(v.vertex); o.uv = TRANSFORM_TEX(v.uv, _MainTex); return o; } fixed4 frag (v2f i) : SV_Target { // sample the texture fixed4 col = tex2D(_MainTex, i.uv); return col; } ENDCG } } } ======================================================================= #version 300 es #define HLSLCC_ENABLE_UNIFORM_BUFFERS 1 #if HLSLCC_ENABLE_UNIFORM_BUFFERS #define UNITY_UNIFORM #else #define UNITY_UNIFORM uniform #endif #define UNITY_SUPPORTS_UNIFORM_LOCATION 1 #if UNITY_SUPPORTS_UNIFORM_LOCATION #define UNITY_LOCATION(x) layout(location = x) #define UNITY_BINDING(x) layout(binding = x, std140) #else #define UNITY_LOCATION(x) #define UNITY_BINDING(x) layout(std140) #endif uniform vec4 hlslcc_mtx4x4unity_ObjectToWorld[4]; uniform vec4 hlslcc_mtx4x4unity_MatrixVP[4]; uniform vec4 _MainTex_ST; in highp vec4 in_POSITION0; in highp vec2 in_TEXCOORD0; out highp vec2 vs_TEXCOORD0; vec4 u_xlat0; vec4 u_xlat1; void main() { vs_TEXCOORD0.xy = in_TEXCOORD0.xy * _MainTex_ST.xy + _MainTex_ST.zw; u_xlat0 = in_POSITION0.yyyy * hlslcc_mtx4x4unity_ObjectToWorld[1]; u_xlat0 = hlslcc_mtx4x4unity_ObjectToWorld[0] * in_POSITION0.xxxx + u_xlat0; u_xlat0 = hlslcc_mtx4x4unity_ObjectToWorld[2] * in_POSITION0.zzzz + u_xlat0; u_xlat0 = u_xlat0 + hlslcc_mtx4x4unity_ObjectToWorld[3]; u_xlat1 = u_xlat0.yyyy * hlslcc_mtx4x4unity_MatrixVP[1]; u_xlat1 = hlslcc_mtx4x4unity_MatrixVP[0] * u_xlat0.xxxx + u_xlat1; u_xlat1 = hlslcc_mtx4x4unity_MatrixVP[2] * u_xlat0.zzzz + u_xlat1; gl_Position = hlslcc_mtx4x4unity_MatrixVP[3] * u_xlat0.wwww + u_xlat1; return; } ============================================================================== #version 300 es precision highp float; precision highp int; #define UNITY_SUPPORTS_UNIFORM_LOCATION 1 #if UNITY_SUPPORTS_UNIFORM_LOCATION #define UNITY_LOCATION(x) layout(location = x) #define UNITY_BINDING(x) layout(binding = x, std140) #else #define UNITY_LOCATION(x) #define UNITY_BINDING(x) layout(std140) #endif UNITY_LOCATION(0) uniform mediump sampler2D _MainTex; in highp vec2 vs_TEXCOORD0; layout(location = 0) out mediump vec4 SV_Target0; mediump vec4 u_xlat16_0; void main() { u_xlat16_0 = texture(_MainTex, vs_TEXCOORD0.xy); SV_Target0 = u_xlat16_0; return; } \u5206\u6790\u7ed3\u679c 2. \u91c7\u6837\u4e24\u6b21 \u4ee3\u7801\uff08\u70b9\u51fb\uff09 v2f vert (appdata v) { v2f o; o.vertex = UnityObjectToClipPos(v.vertex); o.uv = TRANSFORM_TEX(v.uv, _MainTex); return o; } fixed4 frag (v2f i) : SV_Target { // sample the texture fixed4 col = tex2D(_MainTex, i.uv); col.rg = tex2D(_MainTex, i.uv + float2(0, 1)); return col; } =========================================================== #version 300 es precision highp float; precision highp int; #define UNITY_SUPPORTS_UNIFORM_LOCATION 1 #if UNITY_SUPPORTS_UNIFORM_LOCATION #define UNITY_LOCATION(x) layout(location = x) #define UNITY_BINDING(x) layout(binding = x, std140) #else #define UNITY_LOCATION(x) #define UNITY_BINDING(x) layout(std140) #endif UNITY_LOCATION(0) uniform mediump sampler2D _MainTex; in highp vec2 vs_TEXCOORD0; layout(location = 0) out mediump vec4 SV_Target0; vec4 u_xlat0; void main() { u_xlat0.xy = vs_TEXCOORD0.xy + vec2(0.0, 1.0); u_xlat0.xy = texture(_MainTex, u_xlat0.xy).xy; u_xlat0.zw = texture(_MainTex, vs_TEXCOORD0.xy).zw; SV_Target0 = u_xlat0; return; } \u5206\u6790\u7ed3\u679c 3. \u6dfb\u52a0\u9876\u70b9\u6cd5\u7ebf \u4ee3\u7801\uff08\u70b9\u51fb\uff09 struct appdata { float4 vertex : POSITION; float3 normal: NORMAL; // \u9876\u70b9\u6cd5\u7ebf float2 uv1 : TEXCOORD0; }; struct v2f { float4 vertex : SV_POSITION; float3 normalWorld: TEXCOORD1; float2 uv1 : TEXCOORD0; }; sampler2D _MainTex; float4 _MainTex_ST; v2f vert (appdata v) { v2f o; o.vertex = UnityObjectToClipPos(v.vertex); o.uv1 = TRANSFORM_TEX(v.uv1, _MainTex); o.normalWorld = UnityObjectToWorldNormal(v.normal); return o; } fixed4 frag (v2f i) : SV_Target { // sample the texture half2 uv = i.uv1; fixed4 col = tex2D(_MainTex, uv); col.rg = i.normalWorld.xy; return col; } =============================================================== #version 300 es #define HLSLCC_ENABLE_UNIFORM_BUFFERS 1 #if HLSLCC_ENABLE_UNIFORM_BUFFERS #define UNITY_UNIFORM #else #define UNITY_UNIFORM uniform #endif #define UNITY_SUPPORTS_UNIFORM_LOCATION 1 #if UNITY_SUPPORTS_UNIFORM_LOCATION #define UNITY_LOCATION(x) layout(location = x) #define UNITY_BINDING(x) layout(binding = x, std140) #else #define UNITY_LOCATION(x) #define UNITY_BINDING(x) layout(std140) #endif uniform vec4 hlslcc_mtx4x4unity_ObjectToWorld[4]; uniform vec4 hlslcc_mtx4x4unity_WorldToObject[4]; uniform vec4 hlslcc_mtx4x4unity_MatrixVP[4]; uniform vec4 _MainTex_ST; in highp vec4 in_POSITION0; in highp vec3 in_NORMAL0; in highp vec2 in_TEXCOORD0; out highp vec3 vs_TEXCOORD1; out highp vec2 vs_TEXCOORD0; vec4 u_xlat0; vec4 u_xlat1; float u_xlat6; void main() { u_xlat0 = in_POSITION0.yyyy * hlslcc_mtx4x4unity_ObjectToWorld[1]; u_xlat0 = hlslcc_mtx4x4unity_ObjectToWorld[0] * in_POSITION0.xxxx + u_xlat0; u_xlat0 = hlslcc_mtx4x4unity_ObjectToWorld[2] * in_POSITION0.zzzz + u_xlat0; u_xlat0 = u_xlat0 + hlslcc_mtx4x4unity_ObjectToWorld[3]; u_xlat1 = u_xlat0.yyyy * hlslcc_mtx4x4unity_MatrixVP[1]; u_xlat1 = hlslcc_mtx4x4unity_MatrixVP[0] * u_xlat0.xxxx + u_xlat1; u_xlat1 = hlslcc_mtx4x4unity_MatrixVP[2] * u_xlat0.zzzz + u_xlat1; gl_Position = hlslcc_mtx4x4unity_MatrixVP[3] * u_xlat0.wwww + u_xlat1; u_xlat0.x = dot(in_NORMAL0.xyz, hlslcc_mtx4x4unity_WorldToObject[0].xyz); u_xlat0.y = dot(in_NORMAL0.xyz, hlslcc_mtx4x4unity_WorldToObject[1].xyz); u_xlat0.z = dot(in_NORMAL0.xyz, hlslcc_mtx4x4unity_WorldToObject[2].xyz); u_xlat6 = dot(u_xlat0.xyz, u_xlat0.xyz); u_xlat6 = inversesqrt(u_xlat6); vs_TEXCOORD1.xyz = vec3(u_xlat6) * u_xlat0.xyz; vs_TEXCOORD0.xy = in_TEXCOORD0.xy * _MainTex_ST.xy + _MainTex_ST.zw; return; } =========================================================================== #version 300 es precision highp float; precision highp int; #define UNITY_SUPPORTS_UNIFORM_LOCATION 1 #if UNITY_SUPPORTS_UNIFORM_LOCATION #define UNITY_LOCATION(x) layout(location = x) #define UNITY_BINDING(x) layout(binding = x, std140) #else #define UNITY_LOCATION(x) #define UNITY_BINDING(x) layout(std140) #endif UNITY_LOCATION(0) uniform mediump sampler2D _MainTex; in highp vec3 vs_TEXCOORD1; in highp vec2 vs_TEXCOORD0; layout(location = 0) out mediump vec4 SV_Target0; vec4 u_xlat0; void main() { u_xlat0.zw = texture(_MainTex, vs_TEXCOORD0.xy).zw; u_xlat0.xy = vs_TEXCOORD1.xy; SV_Target0 = u_xlat0; return; } \u5206\u6790\u7ed3\u679c o.normalWorld = UnityObjectToWorldNormal(v.normal); \u8f6c\u6362\u6cd5\u7ebf\u5230\u4e16\u754c\u7a7a\u95f4\u540e\u505a\u4e86 normalize , \u4f7f\u7528\u4e86 inversesqrt , \u589e\u52a0\u4e86 SFU \u65b0\u589e\u4e86 in highp vec3 in_NORMAL0; \u548c out highp vec3 vs_TEXCOORD1 \u4f7f\u5f97 LS \u548c V \u4e0a\u5347. 4. \u6dfb\u52a0\u534a\u7cbe\u5ea6\u9876\u70b9\u6cd5\u7ebf \u4ee3\u7801\uff08\u70b9\u51fb\uff09 struct appdata { float4 vertex : POSITION; half3 normal: NORMAL; float2 uv : TEXCOORD0; }; struct v2f { float4 vertex : SV_POSITION; half3 normalWorld: TEXCOORD1; float2 uv : TEXCOORD0; }; ==================================== in mediump vec3 in_NORMAL0; out mediump vec3 vs_TEXCOORD1; \u5206\u6790\u7ed3\u679c \u6539\u4e3a\u534a\u7cbe\u5ea6\u540e V \u5f00\u9500\u4e0b\u964d, SFU \u4e0d\u53d8 \u4e24\u5957uv \u6dfb\u52a0\u7b2c\u4e8c\u5957uv, \u4f46\u4e0d\u4f20\u7ed9 Fragment shader \u4ee3\u7801\uff08\u70b9\u51fb\uff09 struct appdata { float4 vertex : POSITION; half3 normal: NORMAL; half2 uv1 : TEXCOORD0; half2 uv2 : TEXCOORD1; }; struct v2f { float4 vertex : SV_POSITION; half3 normalWorld: TEXCOORD1; half2 uv1 : TEXCOORD0; }; ==================================== in mediump vec3 in_NORMAL0; in mediump vec2 in_TEXCOORD0; in mediump vec2 in_TEXCOORD1; out mediump vec3 vs_TEXCOORD1; out mediump vec2 vs_TEXCOORD0; \u5206\u6790\u7ed3\u679c appData\u7ed3\u6784\u4f53\u5c5e\u6027\u8d8a\u591a, VAO \u8d8a\u5927\u9020\u6210 LS \u4e0a\u5347 5. \u589e\u5927v2f\u4e0d\u6539\u53d8appData \u4ee3\u7801\uff08\u70b9\u51fb\uff09 struct appdata { float4 vertex : POSITION; half3 normal: NORMAL; half2 uv1 : TEXCOORD0; half2 uv2 : TEXCOORD1; }; struct v2f { float4 vertex : SV_POSITION; half3 normalWorld: TEXCOORD1; half2 uv1 : TEXCOORD0; half2 uv2 : TEXCOORD2; half4 uv34 : TEXCOORD3; }; sampler2D _MainTex; float4 _MainTex_ST; v2f vert (appdata v) { v2f o; o.vertex = UnityObjectToClipPos(v.vertex); o.uv1 = TRANSFORM_TEX(v.uv1, _MainTex); o.uv2 = TRANSFORM_TEX(v.uv2, _MainTex);; o.uv34.xy = saturate(o.uv1 + 0.1); o.uv34.zw = saturate(o.uv2 - 0.1); o.normalWorld = UnityObjectToWorldNormal(v.normal); return o; } fixed4 frag (v2f i) : SV_Target { // sample the texture half2 uv = (i.uv1 + i.uv2 + i.uv34.xy + i.uv34.zw) * 0.25; fixed4 col = tex2D(_MainTex, uv); col.r = i.normalWorld.x; return col; } ====================================== in mediump vec3 in_NORMAL0; in mediump vec2 in_TEXCOORD0; in mediump vec2 in_TEXCOORD1; out mediump vec3 vs_TEXCOORD1; out mediump vec2 vs_TEXCOORD0; out mediump vec2 vs_TEXCOORD2; out mediump vec4 vs_TEXCOORD3; \u5206\u6790\u7ed3\u679c \u5728 case4 \u7684\u57fa\u7840\u4e0a, \u5c06 v2f \u589e\u52a0\u4e00\u4e2a half2 \u548c half4 \u53ea\u4f7fvarying\u7684cycles\u6570\u91cf\u4e0a\u5347, LS\u4e0d\u53d8. 6. \u5408\u5e76half4 \u5c06\u591a\u4e2ahalf2\u5408\u5e76\u6210half4 \u4ee3\u7801\uff08\u70b9\u51fb\uff09 struct appdata { float4 vertex : POSITION; half3 normal: NORMAL; half4 uv12 : TEXCOORD0; }; struct v2f { float4 vertex : SV_POSITION; half3 normalWorld: TEXCOORD1; half4 uv12 : TEXCOORD0; half4 uv34 : TEXCOORD2; }; sampler2D _MainTex; float4 _MainTex_ST; v2f vert (appdata v) { v2f o; o.vertex = UnityObjectToClipPos(v.vertex); o.uv12.xy = TRANSFORM_TEX(v.uv12.xy, _MainTex); o.uv12.zw = TRANSFORM_TEX(v.uv12.zw, _MainTex);; o.uv34.xy = saturate(o.uv12.xy + 0.1); o.uv34.zw = saturate(o.uv12.zw - 0.1); o.normalWorld = UnityObjectToWorldNormal(v.normal); return o; } fixed4 frag (v2f i) : SV_Target { // sample the texture half2 uv = (i.uv12.xy + i.uv12.zw + i.uv34.xy + i.uv34.zw) * 0.25; fixed4 col = tex2D(_MainTex, uv); col.r = i.normalWorld.x; return col; } ============================================ in mediump vec3 in_NORMAL0; in mediump vec4 in_TEXCOORD0; out mediump vec3 vs_TEXCOORD1; out mediump vec4 vs_TEXCOORD0; out mediump vec4 vs_TEXCOORD2; \u5206\u6790\u7ed3\u679c appdata \u5408\u5e76\u540e LS \u4e0b\u964d, varying \u4e0d\u53d8 7. \u589e\u52a0\u591a\u4e2auniform\u53d8\u91cf \u4ee3\u7801\uff08\u70b9\u51fb\uff09 float param1; float param2; float param3; float param4; float param5; float param6; struct appdata { float4 vertex : POSITION; half3 normal: NORMAL; half4 uv12 : TEXCOORD0; }; struct v2f { float4 vertex : SV_POSITION; half3 normalWorld: TEXCOORD1; half4 uv12 : TEXCOORD0; half4 uv34 : TEXCOORD2; }; sampler2D _MainTex; float4 _MainTex_ST; v2f vert (appdata v) { v2f o; float param = (param1+param2+param3+param4+param5+param6) / 6.0; o.vertex = UnityObjectToClipPos(v.vertex); o.uv12.xy = TRANSFORM_TEX(v.uv12.xy, _MainTex); o.uv12.zw = TRANSFORM_TEX(v.uv12.zw, _MainTex);; o.uv34.xy = saturate(o.uv12.xy + param); o.uv34.zw = saturate(o.uv12.zw - 0.1); o.normalWorld = UnityObjectToWorldNormal(v.normal); return o; } fixed4 frag (v2f i) : SV_Target { // sample the texture half2 uv = (i.uv12.xy + i.uv12.zw + i.uv34.xy + i.uv34.zw) * 0.25; fixed4 col = tex2D(_MainTex, uv); col.r = i.normalWorld.x; return col; } ========================================================================= #version 300 es #define HLSLCC_ENABLE_UNIFORM_BUFFERS 1 #if HLSLCC_ENABLE_UNIFORM_BUFFERS #define UNITY_UNIFORM #else #define UNITY_UNIFORM uniform #endif #define UNITY_SUPPORTS_UNIFORM_LOCATION 1 #if UNITY_SUPPORTS_UNIFORM_LOCATION #define UNITY_LOCATION(x) layout(location = x) #define UNITY_BINDING(x) layout(binding = x, std140) #else #define UNITY_LOCATION(x) #define UNITY_BINDING(x) layout(std140) #endif uniform vec4 hlslcc_mtx4x4unity_ObjectToWorld[4]; uniform vec4 hlslcc_mtx4x4unity_WorldToObject[4]; uniform vec4 hlslcc_mtx4x4unity_MatrixVP[4]; uniform float param1; uniform float param2; uniform float param3; uniform float param4; uniform float param5; uniform float param6; uniform vec4 _MainTex_ST; in highp vec4 in_POSITION0; in mediump vec3 in_NORMAL0; in mediump vec4 in_TEXCOORD0; out mediump vec3 vs_TEXCOORD1; out mediump vec4 vs_TEXCOORD0; out mediump vec4 vs_TEXCOORD2; vec4 u_xlat0; vec4 u_xlat1; float u_xlat6; void main() { u_xlat0 = in_POSITION0.yyyy * hlslcc_mtx4x4unity_ObjectToWorld[1]; u_xlat0 = hlslcc_mtx4x4unity_ObjectToWorld[0] * in_POSITION0.xxxx + u_xlat0; u_xlat0 = hlslcc_mtx4x4unity_ObjectToWorld[2] * in_POSITION0.zzzz + u_xlat0; u_xlat0 = u_xlat0 + hlslcc_mtx4x4unity_ObjectToWorld[3]; u_xlat1 = u_xlat0.yyyy * hlslcc_mtx4x4unity_MatrixVP[1]; u_xlat1 = hlslcc_mtx4x4unity_MatrixVP[0] * u_xlat0.xxxx + u_xlat1; u_xlat1 = hlslcc_mtx4x4unity_MatrixVP[2] * u_xlat0.zzzz + u_xlat1; gl_Position = hlslcc_mtx4x4unity_MatrixVP[3] * u_xlat0.wwww + u_xlat1; u_xlat0.x = dot(in_NORMAL0.xyz, hlslcc_mtx4x4unity_WorldToObject[0].xyz); u_xlat0.y = dot(in_NORMAL0.xyz, hlslcc_mtx4x4unity_WorldToObject[1].xyz); u_xlat0.z = dot(in_NORMAL0.xyz, hlslcc_mtx4x4unity_WorldToObject[2].xyz); u_xlat6 = dot(u_xlat0.xyz, u_xlat0.xyz); u_xlat6 = inversesqrt(u_xlat6); u_xlat0.xyz = vec3(u_xlat6) * u_xlat0.xyz; vs_TEXCOORD1.xyz = u_xlat0.xyz; u_xlat0 = in_TEXCOORD0 * _MainTex_ST.xyxy + _MainTex_ST.zwzw; vs_TEXCOORD0 = u_xlat0; u_xlat1.x = param2 + param1; u_xlat1.x = u_xlat1.x + param3; u_xlat1.x = u_xlat1.x + param4; u_xlat1.x = u_xlat1.x + param5; u_xlat1.x = u_xlat1.x + param6; u_xlat0.xy = u_xlat1.xx * vec2(0.166666672, 0.166666672) + u_xlat0.xy; #ifdef UNITY_ADRENO_ES3 u_xlat0.xy = min(max(u_xlat0.xy, 0.0), 1.0); #else u_xlat0.xy = clamp(u_xlat0.xy, 0.0, 1.0); #endif vs_TEXCOORD2.zw = u_xlat0.zw + vec2(-0.100000001, -0.100000001); #ifdef UNITY_ADRENO_ES3 vs_TEXCOORD2.zw = min(max(vs_TEXCOORD2.zw, 0.0), 1.0); #else vs_TEXCOORD2.zw = clamp(vs_TEXCOORD2.zw, 0.0, 1.0); #endif vs_TEXCOORD2.xy = u_xlat0.xy; return; } \u5206\u6790\u7ed3\u679c \u6dfb\u52a0 Uniform \u4e0d\u5f71\u54cd LS \u603b\u7ed3 FMA : \u4e0e\u52a0\u51cf\u4e58\u9664\u8ba1\u7b97\u64cd\u4f5c\u6570\u6210\u6b63\u6bd4 CVT : \u4e0e\u4e0d\u540c\u7c7b\u578b\u95f4\u8ba1\u7b97\u6570\u91cf\u6210\u6b63\u6bd4 SFU : \u4e0e inversesqrt , sqrt , normalize \u7b49\u8ba1\u7b97\u51fd\u6570\u4f7f\u7528\u6570\u91cf\u6210\u6b63\u6bd4 LS : \u4e0e\u9876\u70b9\u8f93\u5165\u7ed3\u6784\u4f53\u7684 texcoord \u4f7f\u7528\u6570\u91cf\u6210\u6b63\u6bd4, \u5373\u4f7f\u662f\u540c\u6837\u6570\u91cf\u7684texcoord, \u4f46\u7528 float4 \u548c float2 , LS \u7684\u4e0a\u5347\u662f\u76f8\u540c\u7684. Varying : \u4e0e v2f \u7ed3\u6784\u4f53\u5927\u5c0f, shader\u95f4\u63d2\u503c\u8ba1\u7b97\u6210\u6b63\u6bd4 T : \u4e0e\u8d34\u56fe\u91c7\u6837\u6b21\u6570\u6210\u6b63\u6bd4","title":"Shader\u9759\u6001\u5206\u6790"},{"location":"%E5%9F%BA%E4%BA%8EMalioc%E9%9D%99%E6%80%81%E5%88%86%E6%9E%90Shader/#maliocshader","text":"","title":"\u57fa\u4e8eMalioc\u9759\u6001\u5206\u6790Shader"},{"location":"%E5%9F%BA%E4%BA%8EMalioc%E9%9D%99%E6%80%81%E5%88%86%E6%9E%90Shader/#mali-offline-compiler","text":"malioc \u662f arm \u63a8\u51fa\u7684\u57fa\u4e8e mali GPU \u7684 shader \u79bb\u7ebf\u9759\u6001\u5206\u6790\u5de5\u5177. \u652f\u6301\u4ee5\u4e0bGPU \u2022 Mali-T700 series (Midgard architecture) \u2022 Mali-T800 series (Midgard architecture) \u2022 Mali\u2011G31 (Bifrost architecture) \u2022 Mali\u2011G51 and Mali\u2011G52 (Bifrost architecture) \u2022 Mali\u2011G71, Mali-G72, and Mali-G76 (Bifrost architecture) \u2022 Mali\u2011G57, Mali\u2011G68, Mali\u2011G77, and Mali\u2011G78 (Valhall architecture)","title":"Mali Offline Compiler"},{"location":"%E5%9F%BA%E4%BA%8EMalioc%E9%9D%99%E6%80%81%E5%88%86%E6%9E%90Shader/#_1","text":"\u547d\u4ee4\u884c\u8f93\u5165 malioc -c <target_gpu> [<shader_type>] <file1> [<file2> \u2026] [-o <file>] shader_type \u53ef\u8f93\u5165 \u2022 --vertex \u2022 --tessellation_control \u2022 --tessellation_evaluation \u2022 --geometry \u2022 --fragment \u2022 --compute \u5982\u679c file \u5df2\u7ecf\u4f7f\u7528\u4e86\u4ee5\u4e0b\u6269\u5c55\u540d\u5219\u65e0\u9700\u6307\u5b9a shader_type .vert OpenGL ES vertex shader. .tesc OpenGL ES tessellation control shader. .tese OpenGL ES tessellation evaluation shader. .geom OpenGL ES geometry shader. .frag OpenGL ES fragment shader. .comp OpenGL ES compute shader. \u7528 -D \u53ef\u4ee5\u5b9a\u4e49 Shader \u4e2d\u7684\u5b8f\u6765\u6267\u884c\u90e8\u5206\u4ee3\u7801 -Dfoo \u5b9a\u4e49foo\u4e3a1 -Dfoo=bar \u5b9a\u4e49foo\u4e3abar\u7684\u503c","title":"\u4f7f\u7528\u65b9\u6cd5"},{"location":"%E5%9F%BA%E4%BA%8EMalioc%E9%9D%99%E6%80%81%E5%88%86%E6%9E%90Shader/#_2","text":"\u6267\u884c\u4ee5\u4e0b\u547d\u4ee4\u884c\u4ee3\u7801 $ malioc.exe Unlit-test-LOD100.vert \u5f97\u5230\u4ee5\u4e0b\u6027\u80fd\u6570\u636e Mali Offline Compiler v7.4.0 (Build 330167) Copyright 2007-2021 Arm Limited, all rights reserved Configuration ============= Hardware: Mali-G710 r0p0 Architecture: Valhall Driver: r32p0-00rel0 Shader type: OpenGL ES Vertex Main shader =========== Position variant ---------------- Work registers: 19 Uniform registers: 44 Stack spilling: false 16-bit arithmetic: 0% FMA CVT SFU LS T Bound Total instruction cycles: 0.25 0.00 0.00 2.00 0.00 LS Shortest path cycles: 0.25 0.00 0.00 2.00 0.00 LS Longest path cycles: 0.25 0.00 0.00 2.00 0.00 LS FMA = Arith FMA, CVT = Arith CVT, SFU = Arith SFU, LS = Load/Store, T = Texture Varying variant --------------- Work registers: 7 Uniform registers: 12 Stack spilling: false 16-bit arithmetic: 0% FMA CVT SFU LS T Bound Total instruction cycles: 0.02 0.00 0.00 3.00 0.00 LS Shortest path cycles: 0.02 0.00 0.00 3.00 0.00 LS Longest path cycles: 0.02 0.00 0.00 3.00 0.00 LS FMA = Arith FMA, CVT = Arith CVT, SFU = Arith SFU, LS = Load/Store, T = Texture Shader properties ================= Has uniform computation: false \u770b\u5230 vertex shader \u88ab\u5206\u4e3a\u4e86 Position variant \u548c Varing variant \u4e24\u6bb5. \u5728 Bifrost \u548c Valhall \u67b6\u6784\u4e0a, .vert \u4f1a\u88ab Index-Driven Vertex Shading (IDVS) \u7ba1\u7ebf\u7f16\u8bd1\u6210\u4e24\u4e2a binaries Position shader : \u53ea\u6709 position \u76f8\u5173\u8ba1\u7b97 Varying Shader : \u8ba1\u7b97\u5269\u4e0b\u7684\u6240\u6709 vertex attribute Pos shader \u5bf9\u6bcf\u4e00\u4e2a\u7d22\u5f15\u9876\u70b9\u90fd\u4f1a\u6267\u884c, Varying shader \u53ea\u5bf9\u5254\u9664\u540e\u7684\u53ef\u89c1\u56fe\u5143\u6267\u884c, \u6240\u4ee5\u8fd9\u4e24\u4e2a shader \u7684\u6570\u636e\u88ab\u5206\u5f00\u8868\u793a. \u539f\u6587: The position shader is executed for every index vertex, but the varying shader is only executed for vertices that are part of a visible primitive that survives culling. Mali Offline Compiler reports separate performance tables for each of these variants.","title":"\u6027\u80fd\u5206\u6790"},{"location":"%E5%9F%BA%E4%BA%8EMalioc%E9%9D%99%E6%80%81%E5%88%86%E6%9E%90Shader/#mali-gpu","text":"","title":"Mali GPU \u9759\u6001\u5206\u6790\u6570\u636e\u9879"},{"location":"%E5%9F%BA%E4%BA%8EMalioc%E9%9D%99%E6%80%81%E5%88%86%E6%9E%90Shader/#bifrost","text":"Arithmetic unit (A) \u8ba1\u7b97\u5355\u5143 Load/store unit (LS) \u6267\u884c\u6240\u6709\u975eTexture\u7684\u5185\u5b58\u8bbf\u95ee, \u5305\u62ecbuffer, image\u548c\u539f\u5b50\u64cd\u4f5c, \u53d7 vertex \u7684\u7ed3\u6784\u5927\u5c0f\u5f71\u54cd Varying unit (V) \u6267\u884c\u53d8\u91cf\u63d2\u503c, \u53d7 struct v2f \u5927\u5c0f\u5f71\u54cd Texture unit (T) \u6267\u884c\u6240\u6709\u7eb9\u7406\u91c7\u6837\u548c\u8fc7\u6ee4\u64cd\u4f5c","title":"Bifrost\u67b6\u6784"},{"location":"%E5%9F%BA%E4%BA%8EMalioc%E9%9D%99%E6%80%81%E5%88%86%E6%9E%90Shader/#work-registers","text":"Bifrost GPU shader core \u53ef\u4ee5\u521b\u5efa\u591a\u4e2a\u7ebf\u7a0b, \u53d6\u51b3\u4e8e\u6b63\u5728\u4f7f\u7528\u7684 Shader programs \u7684 work registers \u6570\u91cf 0-32 registers : Maximum thread capacity 33-64 registers : Half thread capacity \u6240\u4ee5\u5982\u679c\u6bd4\u8d77 highp , \u5c3d\u53ef\u80fd\u4f7f\u7528\u66f4\u591a\u7684 mediump \u7684\u8bdd\u5c31\u80fd\u521b\u5efa\u66f4\u591a\u7ebf\u7a0b\u6765\u8ba9 GPU \u7684\u8d1f\u8f7d\u4e0a\u5347\u4ece\u800c\u63d0\u9ad8\u6027\u80fd","title":"Work registers"},{"location":"%E5%9F%BA%E4%BA%8EMalioc%E9%9D%99%E6%80%81%E5%88%86%E6%9E%90Shader/#valhall","text":"Valhall \u67096\u79cd\u5e76\u884c\u7ba1\u7ebf, \u5176\u4e2d3\u79cd arithmetic \u7ba1\u7ebf\u548c3\u79cd fixted function support \u7ba1\u7ebf Arithmetic fused multiply accumulate unit (FMA) FMA\u7ba1\u7ebf\u6784\u5efa\u4e8616-wide warp, \u6bcf\u7ebf\u7a0b\u6bcf\u65f6\u949f\u5468\u671f\u53ef\u4ee5\u53d1\u51fa\u4e00\u4e2a32-bit\u64cd\u4f5c\u6216\u8005\u4e24\u4e2a16bit\u64cd\u4f5c The FMA pipelines are the main arithmetic pipelines, implementing the floating-point multipliers that are widely used in shader code. Each FMA pipeline implements a 16-wide warp, and can issue a single 32-bit operation or two 16-bit operations per thread and per clock cycle. Arithmetic convert unit (CVT) \u7c7b\u578b\u8f6c\u6362\u5355\u5143 The CVT pipelines implement simple operations, such as format conversion and integer addition. Arithmetic special functions unit (SFU) \u7279\u6b8a\u8fd0\u7b97\u5355\u5143, \u7528\u4e8e\u6267\u884c\u5012\u6570\u548c \u8d85\u8d8a\u51fd\u6570 . Each SFU pipeline implements a 4-wide issue path, executing a 16-wide warp over 4 clock cycles Load/store unit (LS) Varying unit (V) Texture unit (T)","title":"Valhall \u67b6\u6784"},{"location":"%E5%9F%BA%E4%BA%8EMalioc%E9%9D%99%E6%80%81%E5%88%86%E6%9E%90Shader/#_3","text":"","title":"\u6d4b\u8bd5\u5404\u9879\u6570\u636e"},{"location":"%E5%9F%BA%E4%BA%8EMalioc%E9%9D%99%E6%80%81%E5%88%86%E6%9E%90Shader/#1-shader","text":"\u4ee5\u6700\u57fa\u7840\u7684shader, \u9876\u70b9\u53ea\u6709pos\u548cuv, \u4e14\u91c7\u6837\u4e00\u6b21\u7eb9\u7406\u5e76\u8f93\u51fa\u7ed3\u679c\u4f5c\u4e3a\u57fa\u51c6shader. \u518d\u6dfb\u52a0\u5176\u5b83\u4ee3\u7801\u89c2\u5bdf\u5404\u9879\u6570\u636e\u7684\u53d8\u5316 \u4ee3\u7801\uff08\u70b9\u51fb\uff09 Shader \"Unlit/benchShader\" { Properties { _MainTex (\"Texture\", 2D) = \"white\" {} } SubShader { Tags { \"RenderType\"=\"Opaque\" } LOD 100 Pass { CGPROGRAM #pragma vertex vert #pragma fragment frag #include \"UnityCG.cginc\" struct appdata { float4 vertex : POSITION; float2 uv : TEXCOORD0; }; struct v2f { float2 uv : TEXCOORD0; float4 vertex : SV_POSITION; }; sampler2D _MainTex; float4 _MainTex_ST; v2f vert (appdata v) { v2f o; o.vertex = UnityObjectToClipPos(v.vertex); o.uv = TRANSFORM_TEX(v.uv, _MainTex); return o; } fixed4 frag (v2f i) : SV_Target { // sample the texture fixed4 col = tex2D(_MainTex, i.uv); return col; } ENDCG } } } ======================================================================= #version 300 es #define HLSLCC_ENABLE_UNIFORM_BUFFERS 1 #if HLSLCC_ENABLE_UNIFORM_BUFFERS #define UNITY_UNIFORM #else #define UNITY_UNIFORM uniform #endif #define UNITY_SUPPORTS_UNIFORM_LOCATION 1 #if UNITY_SUPPORTS_UNIFORM_LOCATION #define UNITY_LOCATION(x) layout(location = x) #define UNITY_BINDING(x) layout(binding = x, std140) #else #define UNITY_LOCATION(x) #define UNITY_BINDING(x) layout(std140) #endif uniform vec4 hlslcc_mtx4x4unity_ObjectToWorld[4]; uniform vec4 hlslcc_mtx4x4unity_MatrixVP[4]; uniform vec4 _MainTex_ST; in highp vec4 in_POSITION0; in highp vec2 in_TEXCOORD0; out highp vec2 vs_TEXCOORD0; vec4 u_xlat0; vec4 u_xlat1; void main() { vs_TEXCOORD0.xy = in_TEXCOORD0.xy * _MainTex_ST.xy + _MainTex_ST.zw; u_xlat0 = in_POSITION0.yyyy * hlslcc_mtx4x4unity_ObjectToWorld[1]; u_xlat0 = hlslcc_mtx4x4unity_ObjectToWorld[0] * in_POSITION0.xxxx + u_xlat0; u_xlat0 = hlslcc_mtx4x4unity_ObjectToWorld[2] * in_POSITION0.zzzz + u_xlat0; u_xlat0 = u_xlat0 + hlslcc_mtx4x4unity_ObjectToWorld[3]; u_xlat1 = u_xlat0.yyyy * hlslcc_mtx4x4unity_MatrixVP[1]; u_xlat1 = hlslcc_mtx4x4unity_MatrixVP[0] * u_xlat0.xxxx + u_xlat1; u_xlat1 = hlslcc_mtx4x4unity_MatrixVP[2] * u_xlat0.zzzz + u_xlat1; gl_Position = hlslcc_mtx4x4unity_MatrixVP[3] * u_xlat0.wwww + u_xlat1; return; } ============================================================================== #version 300 es precision highp float; precision highp int; #define UNITY_SUPPORTS_UNIFORM_LOCATION 1 #if UNITY_SUPPORTS_UNIFORM_LOCATION #define UNITY_LOCATION(x) layout(location = x) #define UNITY_BINDING(x) layout(binding = x, std140) #else #define UNITY_LOCATION(x) #define UNITY_BINDING(x) layout(std140) #endif UNITY_LOCATION(0) uniform mediump sampler2D _MainTex; in highp vec2 vs_TEXCOORD0; layout(location = 0) out mediump vec4 SV_Target0; mediump vec4 u_xlat16_0; void main() { u_xlat16_0 = texture(_MainTex, vs_TEXCOORD0.xy); SV_Target0 = u_xlat16_0; return; } \u5206\u6790\u7ed3\u679c","title":"1. \u57fa\u51c6Shader"},{"location":"%E5%9F%BA%E4%BA%8EMalioc%E9%9D%99%E6%80%81%E5%88%86%E6%9E%90Shader/#2","text":"\u4ee3\u7801\uff08\u70b9\u51fb\uff09 v2f vert (appdata v) { v2f o; o.vertex = UnityObjectToClipPos(v.vertex); o.uv = TRANSFORM_TEX(v.uv, _MainTex); return o; } fixed4 frag (v2f i) : SV_Target { // sample the texture fixed4 col = tex2D(_MainTex, i.uv); col.rg = tex2D(_MainTex, i.uv + float2(0, 1)); return col; } =========================================================== #version 300 es precision highp float; precision highp int; #define UNITY_SUPPORTS_UNIFORM_LOCATION 1 #if UNITY_SUPPORTS_UNIFORM_LOCATION #define UNITY_LOCATION(x) layout(location = x) #define UNITY_BINDING(x) layout(binding = x, std140) #else #define UNITY_LOCATION(x) #define UNITY_BINDING(x) layout(std140) #endif UNITY_LOCATION(0) uniform mediump sampler2D _MainTex; in highp vec2 vs_TEXCOORD0; layout(location = 0) out mediump vec4 SV_Target0; vec4 u_xlat0; void main() { u_xlat0.xy = vs_TEXCOORD0.xy + vec2(0.0, 1.0); u_xlat0.xy = texture(_MainTex, u_xlat0.xy).xy; u_xlat0.zw = texture(_MainTex, vs_TEXCOORD0.xy).zw; SV_Target0 = u_xlat0; return; } \u5206\u6790\u7ed3\u679c","title":"2. \u91c7\u6837\u4e24\u6b21"},{"location":"%E5%9F%BA%E4%BA%8EMalioc%E9%9D%99%E6%80%81%E5%88%86%E6%9E%90Shader/#3","text":"\u4ee3\u7801\uff08\u70b9\u51fb\uff09 struct appdata { float4 vertex : POSITION; float3 normal: NORMAL; // \u9876\u70b9\u6cd5\u7ebf float2 uv1 : TEXCOORD0; }; struct v2f { float4 vertex : SV_POSITION; float3 normalWorld: TEXCOORD1; float2 uv1 : TEXCOORD0; }; sampler2D _MainTex; float4 _MainTex_ST; v2f vert (appdata v) { v2f o; o.vertex = UnityObjectToClipPos(v.vertex); o.uv1 = TRANSFORM_TEX(v.uv1, _MainTex); o.normalWorld = UnityObjectToWorldNormal(v.normal); return o; } fixed4 frag (v2f i) : SV_Target { // sample the texture half2 uv = i.uv1; fixed4 col = tex2D(_MainTex, uv); col.rg = i.normalWorld.xy; return col; } =============================================================== #version 300 es #define HLSLCC_ENABLE_UNIFORM_BUFFERS 1 #if HLSLCC_ENABLE_UNIFORM_BUFFERS #define UNITY_UNIFORM #else #define UNITY_UNIFORM uniform #endif #define UNITY_SUPPORTS_UNIFORM_LOCATION 1 #if UNITY_SUPPORTS_UNIFORM_LOCATION #define UNITY_LOCATION(x) layout(location = x) #define UNITY_BINDING(x) layout(binding = x, std140) #else #define UNITY_LOCATION(x) #define UNITY_BINDING(x) layout(std140) #endif uniform vec4 hlslcc_mtx4x4unity_ObjectToWorld[4]; uniform vec4 hlslcc_mtx4x4unity_WorldToObject[4]; uniform vec4 hlslcc_mtx4x4unity_MatrixVP[4]; uniform vec4 _MainTex_ST; in highp vec4 in_POSITION0; in highp vec3 in_NORMAL0; in highp vec2 in_TEXCOORD0; out highp vec3 vs_TEXCOORD1; out highp vec2 vs_TEXCOORD0; vec4 u_xlat0; vec4 u_xlat1; float u_xlat6; void main() { u_xlat0 = in_POSITION0.yyyy * hlslcc_mtx4x4unity_ObjectToWorld[1]; u_xlat0 = hlslcc_mtx4x4unity_ObjectToWorld[0] * in_POSITION0.xxxx + u_xlat0; u_xlat0 = hlslcc_mtx4x4unity_ObjectToWorld[2] * in_POSITION0.zzzz + u_xlat0; u_xlat0 = u_xlat0 + hlslcc_mtx4x4unity_ObjectToWorld[3]; u_xlat1 = u_xlat0.yyyy * hlslcc_mtx4x4unity_MatrixVP[1]; u_xlat1 = hlslcc_mtx4x4unity_MatrixVP[0] * u_xlat0.xxxx + u_xlat1; u_xlat1 = hlslcc_mtx4x4unity_MatrixVP[2] * u_xlat0.zzzz + u_xlat1; gl_Position = hlslcc_mtx4x4unity_MatrixVP[3] * u_xlat0.wwww + u_xlat1; u_xlat0.x = dot(in_NORMAL0.xyz, hlslcc_mtx4x4unity_WorldToObject[0].xyz); u_xlat0.y = dot(in_NORMAL0.xyz, hlslcc_mtx4x4unity_WorldToObject[1].xyz); u_xlat0.z = dot(in_NORMAL0.xyz, hlslcc_mtx4x4unity_WorldToObject[2].xyz); u_xlat6 = dot(u_xlat0.xyz, u_xlat0.xyz); u_xlat6 = inversesqrt(u_xlat6); vs_TEXCOORD1.xyz = vec3(u_xlat6) * u_xlat0.xyz; vs_TEXCOORD0.xy = in_TEXCOORD0.xy * _MainTex_ST.xy + _MainTex_ST.zw; return; } =========================================================================== #version 300 es precision highp float; precision highp int; #define UNITY_SUPPORTS_UNIFORM_LOCATION 1 #if UNITY_SUPPORTS_UNIFORM_LOCATION #define UNITY_LOCATION(x) layout(location = x) #define UNITY_BINDING(x) layout(binding = x, std140) #else #define UNITY_LOCATION(x) #define UNITY_BINDING(x) layout(std140) #endif UNITY_LOCATION(0) uniform mediump sampler2D _MainTex; in highp vec3 vs_TEXCOORD1; in highp vec2 vs_TEXCOORD0; layout(location = 0) out mediump vec4 SV_Target0; vec4 u_xlat0; void main() { u_xlat0.zw = texture(_MainTex, vs_TEXCOORD0.xy).zw; u_xlat0.xy = vs_TEXCOORD1.xy; SV_Target0 = u_xlat0; return; } \u5206\u6790\u7ed3\u679c o.normalWorld = UnityObjectToWorldNormal(v.normal); \u8f6c\u6362\u6cd5\u7ebf\u5230\u4e16\u754c\u7a7a\u95f4\u540e\u505a\u4e86 normalize , \u4f7f\u7528\u4e86 inversesqrt , \u589e\u52a0\u4e86 SFU \u65b0\u589e\u4e86 in highp vec3 in_NORMAL0; \u548c out highp vec3 vs_TEXCOORD1 \u4f7f\u5f97 LS \u548c V \u4e0a\u5347.","title":"3. \u6dfb\u52a0\u9876\u70b9\u6cd5\u7ebf"},{"location":"%E5%9F%BA%E4%BA%8EMalioc%E9%9D%99%E6%80%81%E5%88%86%E6%9E%90Shader/#4","text":"\u4ee3\u7801\uff08\u70b9\u51fb\uff09 struct appdata { float4 vertex : POSITION; half3 normal: NORMAL; float2 uv : TEXCOORD0; }; struct v2f { float4 vertex : SV_POSITION; half3 normalWorld: TEXCOORD1; float2 uv : TEXCOORD0; }; ==================================== in mediump vec3 in_NORMAL0; out mediump vec3 vs_TEXCOORD1; \u5206\u6790\u7ed3\u679c \u6539\u4e3a\u534a\u7cbe\u5ea6\u540e V \u5f00\u9500\u4e0b\u964d, SFU \u4e0d\u53d8","title":"4. \u6dfb\u52a0\u534a\u7cbe\u5ea6\u9876\u70b9\u6cd5\u7ebf"},{"location":"%E5%9F%BA%E4%BA%8EMalioc%E9%9D%99%E6%80%81%E5%88%86%E6%9E%90Shader/#uv","text":"\u6dfb\u52a0\u7b2c\u4e8c\u5957uv, \u4f46\u4e0d\u4f20\u7ed9 Fragment shader \u4ee3\u7801\uff08\u70b9\u51fb\uff09 struct appdata { float4 vertex : POSITION; half3 normal: NORMAL; half2 uv1 : TEXCOORD0; half2 uv2 : TEXCOORD1; }; struct v2f { float4 vertex : SV_POSITION; half3 normalWorld: TEXCOORD1; half2 uv1 : TEXCOORD0; }; ==================================== in mediump vec3 in_NORMAL0; in mediump vec2 in_TEXCOORD0; in mediump vec2 in_TEXCOORD1; out mediump vec3 vs_TEXCOORD1; out mediump vec2 vs_TEXCOORD0; \u5206\u6790\u7ed3\u679c appData\u7ed3\u6784\u4f53\u5c5e\u6027\u8d8a\u591a, VAO \u8d8a\u5927\u9020\u6210 LS \u4e0a\u5347","title":"\u4e24\u5957uv"},{"location":"%E5%9F%BA%E4%BA%8EMalioc%E9%9D%99%E6%80%81%E5%88%86%E6%9E%90Shader/#5-v2fappdata","text":"\u4ee3\u7801\uff08\u70b9\u51fb\uff09 struct appdata { float4 vertex : POSITION; half3 normal: NORMAL; half2 uv1 : TEXCOORD0; half2 uv2 : TEXCOORD1; }; struct v2f { float4 vertex : SV_POSITION; half3 normalWorld: TEXCOORD1; half2 uv1 : TEXCOORD0; half2 uv2 : TEXCOORD2; half4 uv34 : TEXCOORD3; }; sampler2D _MainTex; float4 _MainTex_ST; v2f vert (appdata v) { v2f o; o.vertex = UnityObjectToClipPos(v.vertex); o.uv1 = TRANSFORM_TEX(v.uv1, _MainTex); o.uv2 = TRANSFORM_TEX(v.uv2, _MainTex);; o.uv34.xy = saturate(o.uv1 + 0.1); o.uv34.zw = saturate(o.uv2 - 0.1); o.normalWorld = UnityObjectToWorldNormal(v.normal); return o; } fixed4 frag (v2f i) : SV_Target { // sample the texture half2 uv = (i.uv1 + i.uv2 + i.uv34.xy + i.uv34.zw) * 0.25; fixed4 col = tex2D(_MainTex, uv); col.r = i.normalWorld.x; return col; } ====================================== in mediump vec3 in_NORMAL0; in mediump vec2 in_TEXCOORD0; in mediump vec2 in_TEXCOORD1; out mediump vec3 vs_TEXCOORD1; out mediump vec2 vs_TEXCOORD0; out mediump vec2 vs_TEXCOORD2; out mediump vec4 vs_TEXCOORD3; \u5206\u6790\u7ed3\u679c \u5728 case4 \u7684\u57fa\u7840\u4e0a, \u5c06 v2f \u589e\u52a0\u4e00\u4e2a half2 \u548c half4 \u53ea\u4f7fvarying\u7684cycles\u6570\u91cf\u4e0a\u5347, LS\u4e0d\u53d8.","title":"5. \u589e\u5927v2f\u4e0d\u6539\u53d8appData"},{"location":"%E5%9F%BA%E4%BA%8EMalioc%E9%9D%99%E6%80%81%E5%88%86%E6%9E%90Shader/#6-half4","text":"\u5c06\u591a\u4e2ahalf2\u5408\u5e76\u6210half4 \u4ee3\u7801\uff08\u70b9\u51fb\uff09 struct appdata { float4 vertex : POSITION; half3 normal: NORMAL; half4 uv12 : TEXCOORD0; }; struct v2f { float4 vertex : SV_POSITION; half3 normalWorld: TEXCOORD1; half4 uv12 : TEXCOORD0; half4 uv34 : TEXCOORD2; }; sampler2D _MainTex; float4 _MainTex_ST; v2f vert (appdata v) { v2f o; o.vertex = UnityObjectToClipPos(v.vertex); o.uv12.xy = TRANSFORM_TEX(v.uv12.xy, _MainTex); o.uv12.zw = TRANSFORM_TEX(v.uv12.zw, _MainTex);; o.uv34.xy = saturate(o.uv12.xy + 0.1); o.uv34.zw = saturate(o.uv12.zw - 0.1); o.normalWorld = UnityObjectToWorldNormal(v.normal); return o; } fixed4 frag (v2f i) : SV_Target { // sample the texture half2 uv = (i.uv12.xy + i.uv12.zw + i.uv34.xy + i.uv34.zw) * 0.25; fixed4 col = tex2D(_MainTex, uv); col.r = i.normalWorld.x; return col; } ============================================ in mediump vec3 in_NORMAL0; in mediump vec4 in_TEXCOORD0; out mediump vec3 vs_TEXCOORD1; out mediump vec4 vs_TEXCOORD0; out mediump vec4 vs_TEXCOORD2; \u5206\u6790\u7ed3\u679c appdata \u5408\u5e76\u540e LS \u4e0b\u964d, varying \u4e0d\u53d8","title":"6. \u5408\u5e76half4"},{"location":"%E5%9F%BA%E4%BA%8EMalioc%E9%9D%99%E6%80%81%E5%88%86%E6%9E%90Shader/#7-uniform","text":"\u4ee3\u7801\uff08\u70b9\u51fb\uff09 float param1; float param2; float param3; float param4; float param5; float param6; struct appdata { float4 vertex : POSITION; half3 normal: NORMAL; half4 uv12 : TEXCOORD0; }; struct v2f { float4 vertex : SV_POSITION; half3 normalWorld: TEXCOORD1; half4 uv12 : TEXCOORD0; half4 uv34 : TEXCOORD2; }; sampler2D _MainTex; float4 _MainTex_ST; v2f vert (appdata v) { v2f o; float param = (param1+param2+param3+param4+param5+param6) / 6.0; o.vertex = UnityObjectToClipPos(v.vertex); o.uv12.xy = TRANSFORM_TEX(v.uv12.xy, _MainTex); o.uv12.zw = TRANSFORM_TEX(v.uv12.zw, _MainTex);; o.uv34.xy = saturate(o.uv12.xy + param); o.uv34.zw = saturate(o.uv12.zw - 0.1); o.normalWorld = UnityObjectToWorldNormal(v.normal); return o; } fixed4 frag (v2f i) : SV_Target { // sample the texture half2 uv = (i.uv12.xy + i.uv12.zw + i.uv34.xy + i.uv34.zw) * 0.25; fixed4 col = tex2D(_MainTex, uv); col.r = i.normalWorld.x; return col; } ========================================================================= #version 300 es #define HLSLCC_ENABLE_UNIFORM_BUFFERS 1 #if HLSLCC_ENABLE_UNIFORM_BUFFERS #define UNITY_UNIFORM #else #define UNITY_UNIFORM uniform #endif #define UNITY_SUPPORTS_UNIFORM_LOCATION 1 #if UNITY_SUPPORTS_UNIFORM_LOCATION #define UNITY_LOCATION(x) layout(location = x) #define UNITY_BINDING(x) layout(binding = x, std140) #else #define UNITY_LOCATION(x) #define UNITY_BINDING(x) layout(std140) #endif uniform vec4 hlslcc_mtx4x4unity_ObjectToWorld[4]; uniform vec4 hlslcc_mtx4x4unity_WorldToObject[4]; uniform vec4 hlslcc_mtx4x4unity_MatrixVP[4]; uniform float param1; uniform float param2; uniform float param3; uniform float param4; uniform float param5; uniform float param6; uniform vec4 _MainTex_ST; in highp vec4 in_POSITION0; in mediump vec3 in_NORMAL0; in mediump vec4 in_TEXCOORD0; out mediump vec3 vs_TEXCOORD1; out mediump vec4 vs_TEXCOORD0; out mediump vec4 vs_TEXCOORD2; vec4 u_xlat0; vec4 u_xlat1; float u_xlat6; void main() { u_xlat0 = in_POSITION0.yyyy * hlslcc_mtx4x4unity_ObjectToWorld[1]; u_xlat0 = hlslcc_mtx4x4unity_ObjectToWorld[0] * in_POSITION0.xxxx + u_xlat0; u_xlat0 = hlslcc_mtx4x4unity_ObjectToWorld[2] * in_POSITION0.zzzz + u_xlat0; u_xlat0 = u_xlat0 + hlslcc_mtx4x4unity_ObjectToWorld[3]; u_xlat1 = u_xlat0.yyyy * hlslcc_mtx4x4unity_MatrixVP[1]; u_xlat1 = hlslcc_mtx4x4unity_MatrixVP[0] * u_xlat0.xxxx + u_xlat1; u_xlat1 = hlslcc_mtx4x4unity_MatrixVP[2] * u_xlat0.zzzz + u_xlat1; gl_Position = hlslcc_mtx4x4unity_MatrixVP[3] * u_xlat0.wwww + u_xlat1; u_xlat0.x = dot(in_NORMAL0.xyz, hlslcc_mtx4x4unity_WorldToObject[0].xyz); u_xlat0.y = dot(in_NORMAL0.xyz, hlslcc_mtx4x4unity_WorldToObject[1].xyz); u_xlat0.z = dot(in_NORMAL0.xyz, hlslcc_mtx4x4unity_WorldToObject[2].xyz); u_xlat6 = dot(u_xlat0.xyz, u_xlat0.xyz); u_xlat6 = inversesqrt(u_xlat6); u_xlat0.xyz = vec3(u_xlat6) * u_xlat0.xyz; vs_TEXCOORD1.xyz = u_xlat0.xyz; u_xlat0 = in_TEXCOORD0 * _MainTex_ST.xyxy + _MainTex_ST.zwzw; vs_TEXCOORD0 = u_xlat0; u_xlat1.x = param2 + param1; u_xlat1.x = u_xlat1.x + param3; u_xlat1.x = u_xlat1.x + param4; u_xlat1.x = u_xlat1.x + param5; u_xlat1.x = u_xlat1.x + param6; u_xlat0.xy = u_xlat1.xx * vec2(0.166666672, 0.166666672) + u_xlat0.xy; #ifdef UNITY_ADRENO_ES3 u_xlat0.xy = min(max(u_xlat0.xy, 0.0), 1.0); #else u_xlat0.xy = clamp(u_xlat0.xy, 0.0, 1.0); #endif vs_TEXCOORD2.zw = u_xlat0.zw + vec2(-0.100000001, -0.100000001); #ifdef UNITY_ADRENO_ES3 vs_TEXCOORD2.zw = min(max(vs_TEXCOORD2.zw, 0.0), 1.0); #else vs_TEXCOORD2.zw = clamp(vs_TEXCOORD2.zw, 0.0, 1.0); #endif vs_TEXCOORD2.xy = u_xlat0.xy; return; } \u5206\u6790\u7ed3\u679c \u6dfb\u52a0 Uniform \u4e0d\u5f71\u54cd LS","title":"7. \u589e\u52a0\u591a\u4e2auniform\u53d8\u91cf"},{"location":"%E5%9F%BA%E4%BA%8EMalioc%E9%9D%99%E6%80%81%E5%88%86%E6%9E%90Shader/#_4","text":"FMA : \u4e0e\u52a0\u51cf\u4e58\u9664\u8ba1\u7b97\u64cd\u4f5c\u6570\u6210\u6b63\u6bd4 CVT : \u4e0e\u4e0d\u540c\u7c7b\u578b\u95f4\u8ba1\u7b97\u6570\u91cf\u6210\u6b63\u6bd4 SFU : \u4e0e inversesqrt , sqrt , normalize \u7b49\u8ba1\u7b97\u51fd\u6570\u4f7f\u7528\u6570\u91cf\u6210\u6b63\u6bd4 LS : \u4e0e\u9876\u70b9\u8f93\u5165\u7ed3\u6784\u4f53\u7684 texcoord \u4f7f\u7528\u6570\u91cf\u6210\u6b63\u6bd4, \u5373\u4f7f\u662f\u540c\u6837\u6570\u91cf\u7684texcoord, \u4f46\u7528 float4 \u548c float2 , LS \u7684\u4e0a\u5347\u662f\u76f8\u540c\u7684. Varying : \u4e0e v2f \u7ed3\u6784\u4f53\u5927\u5c0f, shader\u95f4\u63d2\u503c\u8ba1\u7b97\u6210\u6b63\u6bd4 T : \u4e0e\u8d34\u56fe\u91c7\u6837\u6b21\u6570\u6210\u6b63\u6bd4","title":"\u603b\u7ed3"}]}